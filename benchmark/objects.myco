# Object and Class Performance Benchmark
# Tests object creation, method calls, and inheritance

let iterations = 10000;
let start_time = time.now().unix_timestamp();

# Test object creation and property access
let objects = [];
for i in range(1, iterations + 1):
    let obj = {};
    obj.id = i;
    obj.value = i * 2;
    obj.name = "Object" + i.toString();
    obj.computed = (i * i).sqrt();
    objects.push(obj);
end

# Test property access
let property_sum = 0;
for i in range(0, objects.length):
    property_sum = property_sum + objects[i].value;
end

# Test property modification
for i in range(0, objects.length):
    objects[i].value = objects[i].value * 3;
end

# Test class instantiation
class Point:
    let x: Float
    let y: Float
    
    func distance_to(other):
        let dx = self.x - other.x;
        let dy = self.y - other.y;
        return (dx * dx + dy * dy).sqrt();
    end
    
    func move(dx, dy):
        self.x = self.x + dx;
        self.y = self.y + dy;
    end
end

let points = [];
for i in range(1, 1000):
    let p = Point(i * 1.5, i * 2.5);
    points.push(p);
end

# Test method calls
let distance_sum = 0;
for i in range(0, points.length - 1):
    distance_sum = distance_sum + points[i].distance_to(points[i + 1]);
end

# Test inheritance
class Shape:
    let area: Float
    
    func get_area():
        return self.area;
    end
end

class Circle extends Shape:
    let radius: Float
    
    func get_area():
        return 3.14159 * self.radius * self.radius;
    end
end

class Rectangle extends Shape:
    let width: Float
    let height: Float
    
    func get_area():
        return self.width * self.height;
    end
end

let shapes = [];
for i in range(1, 500):
    let circle = Circle();
    circle.radius = i * 0.5;
    shapes.push(circle);
    
    let rect = Rectangle();
    rect.width = i * 1.0;
    rect.height = i * 2.0;
    shapes.push(rect);
end

# Test polymorphic method calls
let area_sum = 0;
for i in range(0, shapes.length):
    area_sum = area_sum + shapes[i].get_area();
end

# Test object composition
class ComplexObject:
    let points: Array
    let metadata: Object
    
    func initialize():
        self.points = [];
        self.metadata = {};
        self.metadata.created = time.now().unix_timestamp();
    end
    
    func add_point(x, y):
        let p = Point(x, y);
        self.points.push(p);
    end
    
    func total_distance():
        let total = 0.0;
        for i in range(0, self.points.length - 1):
            total = total + self.points[i].distance_to(self.points[i + 1]);
        end
        return total;
    end
end

let complex_objects = [];
for i in range(1, 100):
    let obj = ComplexObject();
    obj.initialize();
    for j in range(1, 10):
        obj.add_point(j * i, j * i * 2);
    end
    complex_objects.push(obj);
end

let complex_sum = 0;
for i in range(0, complex_objects.length):
    complex_sum = complex_sum + complex_objects[i].total_distance();
end

let end_time = time.now().unix_timestamp();
let duration = end_time - start_time;

print("Object Benchmark Results:");
print("Objects created:", objects.length);
print("Property sum:", property_sum);
print("Points created:", points.length);
print("Distance sum:", distance_sum);
print("Shapes created:", shapes.length);
print("Area sum:", area_sum);
print("Complex objects:", complex_objects.length);
print("Complex sum:", complex_sum);
print("Duration (seconds):", duration);
print("Object operations per second:", (iterations * 4 + 1000 * 2 + 1000 * 2 + 100 * 10) / duration);
