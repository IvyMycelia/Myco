# Discord Bot Module for Myco
# A high-level wrapper around the Gateway library for creating Discord bots
#
# Usage:
#   use "discord.myco" as discord;
#   let bot = discord.createBot("YOUR_BOT_TOKEN");
#   bot.on("ready", func(event): print("Bot is ready!"); end);
#   bot.on("messageCreate", func(event): 
#       let msg = event.data;
#       if msg.content == "!ping":
#           bot.sendMessage(msg.channel_id, "Pong!");
#       end
#   end);
#   bot.connect();

requires net;

use gateway as gateway;
use json as json;
use http as http;

# Discord Gateway URL
let DISCORD_GATEWAY_URL = "wss://gateway.discord.gg/?v=10&encoding=json";

# Discord Gateway Opcodes (matching Gateway library)
let OPCODE_DISPATCH = 0;
let OPCODE_HEARTBEAT = 1;
let OPCODE_IDENTIFY = 2;
let OPCODE_STATUS_UPDATE = 3;
let OPCODE_VOICE_STATE_UPDATE = 4;
let OPCODE_RESUME = 6;
let OPCODE_RECONNECT = 7;
let OPCODE_REQUEST_GUILD_MEMBERS = 8;
let OPCODE_INVALID_SESSION = 9;
let OPCODE_HELLO = 10;
let OPCODE_HEARTBEAT_ACK = 11;

# Discord Event Names
let EVENT_READY = "READY";
let EVENT_MESSAGE_CREATE = "MESSAGE_CREATE";
let EVENT_MESSAGE_UPDATE = "MESSAGE_UPDATE";
let EVENT_MESSAGE_DELETE = "MESSAGE_DELETE";
let EVENT_MESSAGE_REACTION_ADD = "MESSAGE_REACTION_ADD";
let EVENT_MESSAGE_REACTION_REMOVE = "MESSAGE_REACTION_REMOVE";
let EVENT_GUILD_CREATE = "GUILD_CREATE";
let EVENT_GUILD_UPDATE = "GUILD_UPDATE";
let EVENT_GUILD_DELETE = "GUILD_DELETE";
let EVENT_CHANNEL_CREATE = "CHANNEL_CREATE";
let EVENT_CHANNEL_UPDATE = "CHANNEL_UPDATE";
let EVENT_CHANNEL_DELETE = "CHANNEL_DELETE";
let EVENT_MEMBER_JOIN = "GUILD_MEMBER_ADD";
let EVENT_MEMBER_UPDATE = "GUILD_MEMBER_UPDATE";
let EVENT_MEMBER_LEAVE = "GUILD_MEMBER_REMOVE";

# Discord Intents - Bit flags for Gateway intents
export let Intents = {
    # Privileged intents (require bot verification)
    GUILDS: 1 << 0,
    GUILD_MEMBERS: 1 << 1,
    GUILD_BANS: 1 << 2,
    GUILD_EMOJIS_AND_STICKERS: 1 << 3,
    GUILD_INTEGRATIONS: 1 << 4,
    GUILD_WEBHOOKS: 1 << 5,
    GUILD_INVITES: 1 << 6,
    GUILD_VOICE_STATES: 1 << 7,
    GUILD_PRESENCES: 1 << 8,
    GUILD_MESSAGES: 1 << 9,
    GUILD_MESSAGE_REACTIONS: 1 << 10,
    GUILD_MESSAGE_TYPING: 1 << 11,
    DIRECT_MESSAGES: 1 << 12,
    DIRECT_MESSAGE_REACTIONS: 1 << 13,
    DIRECT_MESSAGE_TYPING: 1 << 14,
    MESSAGE_CONTENT: 1 << 15,
    GUILD_SCHEDULED_EVENTS: 1 << 16,
    AUTO_MODERATION_CONFIGURATION: 1 << 20,
    AUTO_MODERATION_EXECUTION: 1 << 21,
    
    # Convenience combinations
    all: function() -> Number:
        return (1 << 22) - 1;  # All intents
    end,
    
    default: function() -> Number:
        # Default intents (non-privileged)
        return Intents.GUILDS | Intents.GUILD_MESSAGES | Intents.GUILD_MESSAGE_REACTIONS | 
               Intents.DIRECT_MESSAGES | Intents.DIRECT_MESSAGE_REACTIONS;
    end,
    
    privileged: function() -> Number:
        # Privileged intents (require bot verification)
        return Intents.GUILD_MEMBERS | Intents.GUILD_PRESENCES | Intents.MESSAGE_CONTENT;
    end
};

# EmbedBuilder - Fluent API for building Discord embeds
export func EmbedBuilder() -> Object:
    let embed = {
        title: null,
        description: null,
        color: 0,
        fields: [],
        timestamp: null,
        footer: null,
        image: null,
        thumbnail: null,
        author: null,
        url: null,
        
        set_title: function(title: String) -> Object:
            embed.title = title;
            return embed;
        end,
        
        set_description: function(description: String) -> Object:
            embed.description = description;
            return embed;
        end,
        
        set_color: function(color: Number) -> Object:
            embed.color = color;
            return embed;
        end,
        
        add_field: function(name: String, value: String, inline: Boolean = false) -> Object:
            let field = {
                name: name,
                value: value,
                inline: inline
            };
            embed.fields.push(field);
            return embed;
        end,
        
        set_footer: function(text: String, icon_url: String = null) -> Object:
            embed.footer = {
                text: text,
                icon_url: icon_url
            };
            return embed;
        end,
        
        set_image: function(url: String) -> Object:
            embed.image = {url: url};
            return embed;
        end,
        
        set_thumbnail: function(url: String) -> Object:
            embed.thumbnail = {url: url};
            return embed;
        end,
        
        set_author: function(name: String, icon_url: String = null, url: String = null) -> Object:
            embed.author = {
                name: name,
                icon_url: icon_url,
                url: url
            };
            return embed;
        end,
        
        set_url: function(url: String) -> Object:
            embed.url = url;
            return embed;
        end,
        
        set_timestamp: function(timestamp: String = null) -> Object:
            # If no timestamp provided, use current time in ISO 8601 format
            if timestamp == null:
                # Simple timestamp generation (would need proper date formatting in production)
                embed.timestamp = null;  # Could be set to current time
            else:
                embed.timestamp = timestamp;
            end
            return embed;
        end,
        
        # Build the final embed object (for compatibility)
        build: function() -> Object:
            let result = {};
            if embed.title != null: result.title = embed.title; end
            if embed.description != null: result.description = embed.description; end
            result.color = embed.color;
            if embed.fields.length > 0: result.fields = embed.fields; end
            if embed.timestamp != null: result.timestamp = embed.timestamp; end
            if embed.footer != null: result.footer = embed.footer; end
            if embed.image != null: result.image = embed.image; end
            if embed.thumbnail != null: result.thumbnail = embed.thumbnail; end
            if embed.author != null: result.author = embed.author; end
            if embed.url != null: result.url = embed.url; end
            return result;
        end
    };
    return embed;
end;

# Client class
export func Client(intents: Number = null) -> Object:
    if intents == null:
        intents = Intents.default();
    end
    
    let client = {
        token: null,
        intents: intents,
        user: null,
        guilds: {},
        eventHandlers: {},
        __gateway__: null,
        
        # Connect to Discord
        connect: async function(token: String) -> Null:
            if token == null or token == "":
                print("Error: Bot token is required");
                return;
            end
            
            client.token = token;
            
            # Create gateway configuration
            # Use object literal syntax to ensure it's an object, not a set
            # Create config with all properties at once to ensure it's a hash map, not a set
            let config = {
                token: token,
                version: 10,
                encoding: "json",
                intents: intents
            };
            
            # Create gateway connection
            let gw = gateway.create(DISCORD_GATEWAY_URL, config);
            if gw == null:
                print("Error: Failed to create gateway connection");
                return;
            end
            
            client.__gateway__ = gw;
            
            # Set up event handlers
            gw.on("ready", function(event):
                # Store bot user info
                if event.data != null and event.data.user != null:
                    client.user = event.data.user;
                end
                # Store guilds (Discord sends guilds in the READY event as an array)
                if event.data != null and event.data.guilds != null:
                    # Convert guilds array to object for easier access
                    let guilds_obj = {};
                    if event.data.guilds.length != null:
                        for let i = 0; i < event.data.guilds.length; i++:
                            let guild = event.data.guilds[i];
                            if guild != null and guild.id != null:
                                guilds_obj[guild.id] = guild;
                            end
                        end
                    end
                    client.guilds = guilds_obj;
                end
                # Call user callback (this is when the bot is actually ready)
                if client.eventHandlers["ready"] != null:
                    client.eventHandlers["ready"](client);
                end
                # Print connection completed message when ready
                print("Connection completed - Bot is ready!");
            end);
            
            gw.on("event", function(event):
                let eventType = event.name;
                
                # Handle MESSAGE_CREATE -> on_message
                if eventType == EVENT_MESSAGE_CREATE:
                    if client.eventHandlers["message"] != null and event.data != null:
                        client.eventHandlers["message"](event.data);
                    end
                end
                
                # Handle GUILD_MEMBER_ADD -> on_member_join
                if eventType == EVENT_MEMBER_JOIN:
                    if client.eventHandlers["member_join"] != null and event.data != null:
                        client.eventHandlers["member_join"](event.data);
                    end
                end
                
                # Generic event handler support (for future extensibility)
                # Users can register handlers for any event type
                if client.eventHandlers[eventType] != null and event.data != null:
                    client.eventHandlers[eventType](event.data);
                end
            end);
            
            # Connect (this is async and will establish the connection)
            await gw.connect();
            
            # Note: The ready event will be fired asynchronously when Discord sends it
            # The connect() call above initiates the connection but doesn't wait for ready
        end,
        
        # Event handlers
        on_ready: function(callback: Function) -> Null:
            client.eventHandlers["ready"] = callback;
        end,
        
        on_message: function(callback: Function) -> Null:
            client.eventHandlers["message"] = callback;
        end,
        
        on_member_join: function(callback: Function) -> Null:
            client.eventHandlers["member_join"] = callback;
        end,
        
        # Generic event handler (for custom events)
        on: function(event_name: String, callback: Function) -> Null:
            if event_name == null or callback == null:
                return;
            end
            client.eventHandlers[event_name] = callback;
        end,
        
        # Send message
        send_message: async function(channel_id: String, content: String, options: Object = null) -> Object:
            if channel_id == null:
                return null;
            end
            
            if client.token == null:
                return null;
            end
            
            # Create message payload
            let payload = {};
            if content != null and content != "":
                payload.content = content;
            end
            
            # Handle embed from options
            if options != null and options.embed != null:
                # If it's an EmbedBuilder, build it
                let embed = options.embed;
                if embed.build != null:
                    embed = embed.build();
                end
                payload.embeds = [embed];
            end
            
            # Convert payload to JSON
            let jsonPayload = json.stringify(payload);
            if jsonPayload == null:
                print("Error: Failed to stringify message payload");
                return null;
            end
            
            # Discord API endpoint
            let url = "https://discord.com/api/v10/channels/" + channel_id + "/messages";
            
            # Create headers with Authorization
            let headers = {
                "Authorization": "Bot " + client.token,
                "Content-Type": "application/json"
            };
            
            # Send POST request with headers
            let response = http.post(url, jsonPayload, headers);
            
            if response == null or not response.success:
                print("Error: Failed to send message. Status: " + (response != null ? response.status_code.toString() : "unknown"));
                if response != null and response.body != null:
                    print("Response body: " + response.body);
                end
                return null;
            end
            
            # Parse response
            if response.body != null:
                let messageData = json.parse(response.body);
                return messageData;
            end
            
            return null;
        end,
        
        # Close/disconnect
        close: async function() -> Null:
            if client.__gateway__ != null:
                await client.__gateway__.disconnect();
            end
        end
    };
    
    return client;
end;

# Create a Discord bot instance
func createBot(token: String) -> Object:
    if token == null or token == "":
        print("Error: Bot token is required");
        return null;
    end
    
    # Create gateway configuration with all properties at once to ensure it's a hash map, not a set
    # Include intents for receiving messages and guild events
    # GUILDS (1 << 0) = 1, GUILD_MESSAGES (1 << 9) = 512, MESSAGE_CONTENT (1 << 15) = 32768
    # Combined: 1 | 512 | 32768 = 33281
    let config = {
        token: token,
        version: 10,
        encoding: "json",
        intents: 33281
    };
    
    # Create gateway connection
    let gw = gateway.create(DISCORD_GATEWAY_URL, config);
    if gw == null:
        print("Error: Failed to create gateway connection");
        return null;
    end
    
    # Set up error handler
    gw.on("error", func(error):
        if error == null:
            return;
        end
        let code = 0;
        if error.code != null:
            code = error.code;
        end
        let message = "Unknown error";
        if error.message != null:
            message = error.message;
        end
        print("Discord Gateway Error: " + message + " (code: " + code.toString() + ")");
        if code == 4002:
            print("This usually means the bot token is invalid or the payload format is incorrect.");
        end
    end);
    
    # Create bot object with all properties at once to ensure it's a hash map, not a set
    # Note: The gateway object uses __gateway_conn__ internally, but we store it as __gateway__ for convenience
    let bot = {
        __gateway__: gw,
        token: token,
        user: null,
        guilds: {},
        eventHandlers: {},
        eventCallbackRegistered: false
    };
    
    # Debug: Check if gateway object has the correct property
    if gw != null:
        print("Gateway object created, checking properties...");
        # The gateway object should have __gateway_conn__ set by gateway.create()
    end
    
    # Wrapper methods
    # Create a wrapper function that doesn't execute immediately
    let connect_func = async function():
        await gw.connect();
    end;
    
    bot.connect = connect_func;
    
    let disconnect_func = async function():
        await gw.disconnect();
    end;
    bot.disconnect = disconnect_func;
    
    bot.getState = func() -> String:
        return gw.getState();
    end;
    
    # Event handler registration
    # Use BC_PROPERTY_SET to assign the function
    # Access gateway through bot.__gateway__ to avoid closure issues
    bot.on = func(eventName: String, callback: Function):
        if eventName == null or callback == null:
            return;
        end
        
        # Store event handler
        print("Storing handler for event: " + eventName);
        print("Callback type before storing: " + callback.type.toString());
        
        # Debug: Check if callback is a bytecode function and log its ID
        # For bytecode functions, the body field contains the function ID (cast as pointer)
        # We can't easily access this from Myco, but we can at least verify the type
        
        bot.eventHandlers[eventName] = callback;
        print("Handler stored, retrieving to verify...");
        let stored = bot.eventHandlers[eventName];
        print("Stored handler type: " + stored.type.toString());
        if stored.type != callback.type:
            print("ERROR: Handler type mismatch! Expected " + callback.type.toString() + ", got " + stored.type.toString());
        end
        
        # Verify the stored function is actually callable
        if stored.type.toString() == "Function":
            print("Stored handler is a Function - verification passed");
        else:
            print("WARNING: Stored handler is not a Function, it's: " + stored.type.toString());
        end
        
        # Get gateway from bot object to avoid closure issues
        let gw = bot.__gateway__;
        if gw == null:
            return;
        end
        
        # Register with gateway
        if eventName == "ready":
            gw.on("ready", func(event):
                # Store bot user info (if event.data.user is accessible)
                if event.data != null and event.data.user != null:
                    bot.user = event.data.user;
                end
                # Call user callback
                if bot.eventHandlers["ready"] != null:
                    bot.eventHandlers["ready"](event);
                end
                # Print login message (only if user callback didn't print it)
                # Use username and user_id extracted by gateway (bypasses nested property access issue)
                if event.username != null and event.user_id != null:
                    print("Logged in as " + event.username + " (" + event.user_id + ")");
                end
            end);
        else:
            # For all other events, use the generic event handler
            # Only register the event callback once (it will check all handlers)
            if not bot.eventCallbackRegistered:
                bot.eventCallbackRegistered = true;
                gw.on("event", func(event):
                    let eventType = event.name;
                    print("Event received: " + eventType);
                    
                    # Check each registered event handler
                    # Map camelCase event names to Discord's uppercase format and check if they match
                    print("Checking for messageCreate handler...");
                    print("eventHandlers type: " + bot.eventHandlers.type.toString());
                    if bot.eventHandlers["messageCreate"] != null:
                        print("messageCreate handler exists, checking if event matches...");
                        if eventType == "messageCreate" or eventType == "MESSAGE_CREATE":
                            print("Calling messageCreate handler!");
                            let handler = bot.eventHandlers["messageCreate"];
                            print("Handler retrieved, type: " + handler.type.toString());
                            if handler.type.toString() == "Function":
                                print("Handler is a function, about to invoke with event...");
                                print("Event type: " + event.type.toString());
                                print("Event name: " + (event.name != null ? event.name : "null"));
                                print("Event data type: " + (event.data != null ? event.data.type.toString() : "null"));
                                print("About to call handler(event)...");
                                # The handler should immediately print "messageCreate handler called!"
                                # If we don't see that, the wrong function is being called
                                let result = handler(event);
                                print("Handler returned, result type: " + result.type.toString());
                            else:
                                print("ERROR: Handler is not a function! Type: " + handler.type.toString());
                            end
                        else:
                            print("Event type mismatch: expected 'messageCreate' or 'MESSAGE_CREATE', got '" + eventType + "'");
                        end
                    else:
                        print("messageCreate handler is null!");
                    end
                    if bot.eventHandlers["messageUpdate"] != null:
                        if eventType == "messageUpdate" or eventType == "MESSAGE_UPDATE":
                            bot.eventHandlers["messageUpdate"](event);
                        end
                    end
                    if bot.eventHandlers["messageDelete"] != null:
                        if eventType == "messageDelete" or eventType == "MESSAGE_DELETE":
                            bot.eventHandlers["messageDelete"](event);
                        end
                    end
                    if bot.eventHandlers["guildCreate"] != null:
                        if eventType == "guildCreate" or eventType == "GUILD_CREATE":
                            bot.eventHandlers["guildCreate"](event);
                        end
                    end
                    if bot.eventHandlers["guildUpdate"] != null:
                        if eventType == "guildUpdate" or eventType == "GUILD_UPDATE":
                            bot.eventHandlers["guildUpdate"](event);
                        end
                    end
                    if bot.eventHandlers["guildDelete"] != null:
                        if eventType == "guildDelete" or eventType == "GUILD_DELETE":
                            bot.eventHandlers["guildDelete"](event);
                        end
                    end
                    if bot.eventHandlers["channelCreate"] != null:
                        if eventType == "channelCreate" or eventType == "CHANNEL_CREATE":
                            bot.eventHandlers["channelCreate"](event);
                        end
                    end
                    if bot.eventHandlers["channelUpdate"] != null:
                        if eventType == "channelUpdate" or eventType == "CHANNEL_UPDATE":
                            bot.eventHandlers["channelUpdate"](event);
                        end
                    end
                    if bot.eventHandlers["channelDelete"] != null:
                        if eventType == "channelDelete" or eventType == "CHANNEL_DELETE":
                            bot.eventHandlers["channelDelete"](event);
                        end
                    end
                    if bot.eventHandlers["memberJoin"] != null:
                        if eventType == "memberJoin" or eventType == "GUILD_MEMBER_ADD":
                            bot.eventHandlers["memberJoin"](event);
                        end
                    end
                    if bot.eventHandlers["memberUpdate"] != null:
                        if eventType == "memberUpdate" or eventType == "GUILD_MEMBER_UPDATE":
                            bot.eventHandlers["memberUpdate"](event);
                        end
                    end
                    if bot.eventHandlers["memberLeave"] != null:
                        if eventType == "memberLeave" or eventType == "GUILD_MEMBER_REMOVE":
                            bot.eventHandlers["memberLeave"](event);
                        end
                    end
                end);
            end
        end
    end;
    
    # Send a message to a channel via Discord HTTP API
    bot.sendMessage = func(channelId: String, content: String, embed: Object = null) -> Object:
        if channelId == null or content == null:
            return null;
        end
        
        # Create message payload
        let payload = {};
        payload.content = content;
        if embed != null:
            payload.embeds = [embed];
        end
        
        # Convert payload to JSON
        let jsonPayload = json.stringify(payload);
        if jsonPayload == null:
            print("Error: Failed to stringify message payload");
            return null;
        end
        
        # Discord API endpoint
        let url = "https://discord.com/api/v10/channels/" + channelId + "/messages";
        
        # Create headers with Authorization
        let headers = {
            "Authorization": "Bot " + bot.token,
            "Content-Type": "application/json"
        };
        
        # Send POST request with headers
        let response = http.post(url, jsonPayload, headers);
        
        if response == null or not response.success:
            print("Error: Failed to send message. Status: " + (response != null ? response.status_code.toString() : "unknown"));
            return null;
        end
        
        # Parse response
        if response.body != null:
            let messageData = json.parse(response.body);
            return messageData;
        end
        
        return null;
    end;
    
    # React to a message via Discord HTTP API
    bot.react = func(channelId: String, messageId: String, emoji: String) -> Boolean:
        if channelId == null or messageId == null or emoji == null:
            return false;
        end
        
        # URL encode emoji if needed (simplified - may need proper encoding)
        let encodedEmoji = emoji;
        
        # Discord API endpoint for reactions
        let url = "https://discord.com/api/v10/channels/" + channelId + "/messages/" + messageId + "/reactions/" + encodedEmoji + "/@me";
        
        # Create headers with Authorization
        let headers = {
            "Authorization": "Bot " + bot.token,
            "Content-Type": "application/json"
        };
        
        # Send PUT request with headers (Discord uses PUT for reactions)
        let response = http.put(url, "", headers);
        
        if response == null or not response.success:
            print("Error: Failed to add reaction. Status: " + (response != null ? response.status_code.toString() : "unknown"));
            return false;
        end
        
        return true;
    end;
    
    # Get gateway connection (for advanced usage)
    bot.getGateway = func() -> Object:
        return gw;
    end;
    
    return bot;
end;

# Helper function to create a Discord embed
func createEmbed(title: String, description: String, color: Number = 0) -> Object:
    let embed = {};
    embed.title = title;
    embed.description = description;
    embed.color = color;
    embed.fields = [];
    embed.timestamp = null;
    embed.footer = null;
    embed.image = null;
    embed.thumbnail = null;
    return embed;
end;

# Add a field to an embed
func addEmbedField(embed: Object, name: String, value: String, inline: Boolean = false):
    if embed == null or embed.fields == null:
        return;
    end
    
    let field = {};
    field.name = name;
    field.value = value;
    field.inline = inline;
    embed.fields.push(field);
end;

# Helper function to format Discord user mention
func mentionUser(userId: String) -> String:
    return "<@" + userId + ">";
end;

# Helper function to format Discord channel mention
func mentionChannel(channelId: String) -> String:
    return "<#" + channelId + ">";
end;

# Helper function to format Discord role mention
func mentionRole(roleId: String) -> String:
    return "<@&" + roleId + ">";
end;

# Helper function to get user from event data
func getUserFromEvent(event: Object) -> Object:
    if event == null or event.data == null:
        return null;
    end
    
    # Check if event.data has author (for messages)
    if event.data.author != null:
        return event.data.author;
    end
    
    # Check if event.data has user (for other events)
    if event.data.user != null:
        return event.data.user;
    end
    
    return null;
end;

# Helper function to get channel from event data
func getChannelFromEvent(event: Object) -> Object:
    if event == null or event.data == null:
        return null;
    end
    
    if event.data.channel_id != null:
        return {id: event.data.channel_id};
    end
    
    if event.data.channel != null:
        return event.data.channel;
    end
    
    return null;
end;

# Helper function to get guild from event data
func getGuildFromEvent(event: Object) -> Object:
    if event == null or event.data == null:
        return null;
    end
    
    if event.data.guild_id != null:
        return {id: event.data.guild_id};
    end
    
    if event.data.guild != null:
        return event.data.guild;
    end
    
    return null;
end;

# Example usage function (commented out)
# func example():
#     use "discord.myco" as discord;
#     
#     let bot = discord.createBot("YOUR_BOT_TOKEN");
#     
#     bot.on("ready", func(event):
#         print("Bot is ready! Logged in as: " + bot.user.username);
#     end);
#     
#     bot.on("messageCreate", func(event):
#         let msg = event.data;
#         let user = discord.getUserFromEvent(event);
#         let channel = discord.getChannelFromEvent(event);
#         
#         if msg.content == "!ping":
#             bot.sendMessage(channel.id, "Pong!");
#         end
#         
#         if msg.content == "!hello":
#             bot.sendMessage(channel.id, "Hello, " + discord.mentionUser(user.id) + "!");
#         end
#         
#         if msg.content == "!react":
#             bot.react(channel.id, msg.id, "üëç");
#         end
#     end);
#     
#     bot.connect();
# end;

