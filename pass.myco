print("=== Myco Comprehensive Test Suite ===");
print("Testing EVERY feature and edge case in Myco");
print("");

let total_tests = 0;
let tests_passed = 0;
let tests_failed = [];

print("=== 1. BASIC DATA TYPES ===");
print("1.1. Numbers...");
total_tests = total_tests + 1;
let x = 42;
if x == 42:
    print("✓ Integer variable: " + str(x));
    tests_passed = tests_passed + 1;
else:
    print("✗ Integer variable: " + str(x));
    tests_failed = tests_failed + ["Integer variable"];
end

total_tests = total_tests + 1;
let y = 3.14;
if y == 3.14:
    print("✓ Float variable: " + str(y));
    tests_passed = tests_passed + 1;
else:
    print("✗ Float variable: " + str(y));
    tests_failed = tests_failed + ["Float variable"];
end

total_tests = total_tests + 1;
let neg_int = -10;
if neg_int == -10:
    print("✓ Negative integer: " + str(neg_int));
    tests_passed = tests_passed + 1;
else:
    print("✗ Negative integer: " + str(neg_int));
    tests_failed = tests_failed + ["Negative integer"];
end

total_tests = total_tests + 1;
let neg_float = -3.14;
if neg_float == -3.14:
    print("✓ Negative float: " + str(neg_float));
    tests_passed = tests_passed + 1;
else:
    print("✗ Negative float: " + str(neg_float));
    tests_failed = tests_failed + ["Negative float"];
end

total_tests = total_tests + 1;
let zero = 0;
if zero == 0:
    print("✓ Zero: " + str(zero));
    tests_passed = tests_passed + 1;
else:
    print("✗ Zero: " + str(zero));
    tests_failed = tests_failed + ["Zero"];
end

print("\n1.2. Strings...");
total_tests = total_tests + 1;
let name = "Myco";
if name == "Myco":
    print("✓ String variable: " + name);
    tests_passed = tests_passed + 1;
else:
    print("✗ String variable: " + name);
    tests_failed = tests_failed + ["String variable"];
end

total_tests = total_tests + 1;
let empty_str = "";
if empty_str == "":
    print("✓ Empty string: '" + empty_str + "'");
    tests_passed = tests_passed + 1;
else:
    print("✗ Empty string: '" + empty_str + "'");
    tests_failed = tests_failed + ["Empty string"];
end

total_tests = total_tests + 1;
let spaced_str = "hello world";
if spaced_str == "hello world":
    print("✓ String with spaces: " + spaced_str);
    tests_passed = tests_passed + 1;
else:
    print("✗ String with spaces: " + spaced_str);
    tests_failed = tests_failed + ["String with spaces"];
end

print("\n1.3. Booleans...");
total_tests = total_tests + 1;
let flag = True;
if flag == True:
    print("✓ Boolean True: " + str(flag));
    tests_passed = tests_passed + 1;
else:
    print("✗ Boolean True: " + str(flag));
    tests_failed = tests_failed + ["Boolean True"];
end

total_tests = total_tests + 1;
let false_flag = False;
if false_flag == False:
    print("✓ Boolean False: " + str(false_flag));
    tests_passed = tests_passed + 1;
else:
    print("✗ Boolean False: " + str(false_flag));
    tests_failed = tests_failed + ["Boolean False"];
end

print("\n1.4. Null...");
total_tests = total_tests + 1;
let null_var = Null;
if null_var == Null:
    print("✓ Null variable: " + str(null_var));
    tests_passed = tests_passed + 1;
else:
    print("✗ Null variable: " + str(null_var));
    tests_failed = tests_failed + ["Null variable"];
end

print("\n=== 2. ARITHMETIC OPERATIONS ===");
print("2.1. Addition...");
total_tests = total_tests + 1;
let a = 5 + 3;
if a == 8:
    print("✓ Integer addition (5 + 3): " + str(a));
    tests_passed = tests_passed + 1;
else:
    print("✗ Integer addition (5 + 3): " + str(a));
    tests_failed = tests_failed + ["Integer addition"];
end

total_tests = total_tests + 1;
let float_add = 2.5 + 1.5;
if float_add == 4.0:
    print("✓ Float addition (2.5 + 1.5): " + str(float_add));
    tests_passed = tests_passed + 1;
else:
    print("✗ Float addition (2.5 + 1.5): " + str(float_add));
    tests_failed = tests_failed + ["Float addition"];
end

total_tests = total_tests + 1;
let mixed_add = 5 + 2.5;
if mixed_add == 7.5:
    print("✓ Mixed addition (5 + 2.5): " + str(mixed_add));
    tests_passed = tests_passed + 1;
else:
    print("✗ Mixed addition (5 + 2.5): " + str(mixed_add));
    tests_failed = tests_failed + ["Mixed addition"];
end

total_tests = total_tests + 1;
let str_concat = "hello" + "world";
if str_concat == "helloworld":
    print("✓ String concatenation: " + str_concat);
    tests_passed = tests_passed + 1;
else:
    print("✗ String concatenation: " + str_concat);
    tests_failed = tests_failed + ["String concatenation"];
end

print("\n2.2. Subtraction...");
total_tests = total_tests + 1;
let b = 10 - 4;
if b == 6:
    print("✓ Integer subtraction (10 - 4): " + str(b));
    tests_passed = tests_passed + 1;
else:
    print("✗ Integer subtraction (10 - 4): " + str(b));
    tests_failed = tests_failed + ["Integer subtraction"];
end

total_tests = total_tests + 1;
let float_sub = 5.5 - 2.5;
if float_sub == 3.0:
    print("✓ Float subtraction (5.5 - 2.5): " + str(float_sub));
    tests_passed = tests_passed + 1;
else:
    print("✗ Float subtraction (5.5 - 2.5): " + str(float_sub));
    tests_failed = tests_failed + ["Float subtraction"];
end

total_tests = total_tests + 1;
let neg_result = 3 - 5;
if neg_result == -2:
    print("✓ Negative result (3 - 5): " + str(neg_result));
    tests_passed = tests_passed + 1;
else:
    print("✗ Negative result (3 - 5): " + str(neg_result));
    tests_failed = tests_failed + ["Negative result"];
end

print("\n2.3. Multiplication...");
total_tests = total_tests + 1;
let c = 6 * 7;
if c == 42:
    print("✓ Integer multiplication (6 * 7): " + str(c));
    tests_passed = tests_passed + 1;
else:
    print("✗ Integer multiplication (6 * 7): " + str(c));
    tests_failed = tests_failed + ["Integer multiplication"];
end

total_tests = total_tests + 1;
let float_mult = 2.5 * 4;
if float_mult == 10.0:
    print("✓ Float multiplication (2.5 * 4): " + str(float_mult));
    tests_passed = tests_passed + 1;
else:
    print("✗ Float multiplication (2.5 * 4): " + str(float_mult));
    tests_failed = tests_failed + ["Float multiplication"];
end

total_tests = total_tests + 1;
let zero_mult = 5 * 0;
if zero_mult == 0:
    print("✓ Zero multiplication (5 * 0): " + str(zero_mult));
    tests_passed = tests_passed + 1;
else:
    print("✗ Zero multiplication (5 * 0): " + str(zero_mult));
    tests_failed = tests_failed + ["Zero multiplication"];
end

print("\n2.4. Division...");
total_tests = total_tests + 1;
let d = 15 / 3;
if d == 5:
    print("✓ Integer division (15 / 3): " + str(d));
    tests_passed = tests_passed + 1;
else:
    print("✗ Integer division (15 / 3): " + str(d));
    tests_failed = tests_failed + ["Integer division"];
end

total_tests = total_tests + 1;
let float_div = 10.0 / 2.5;
if float_div == 4.0:
    print("✓ Float division (10.0 / 2.5): " + str(float_div));
    tests_passed = tests_passed + 1;
else:
    print("✗ Float division (10.0 / 2.5): " + str(float_div));
    tests_failed = tests_failed + ["Float division"];
end

total_tests = total_tests + 1;
let remainder_div = 7 / 2;
if remainder_div == 3.5:
    print("✓ Division with remainder (7 / 2): " + str(remainder_div));
    tests_passed = tests_passed + 1;
else:
    print("✗ Division with remainder (7 / 2): " + str(remainder_div));
    tests_failed = tests_failed + ["Division with remainder"];
end

print("\n=== 3. COMPARISON OPERATIONS ===");
print("3.1. Equality...");
total_tests = total_tests + 1;
let comp3 = 5 == 5;
if comp3 == True:
    print("✓ Integer equality (5 == 5): " + str(comp3));
    tests_passed = tests_passed + 1;
else:
    print("✗ Integer equality (5 == 5): " + str(comp3));
    tests_failed = tests_failed + ["Integer equality"];
end

total_tests = total_tests + 1;
let comp_neq = 5 == 6;
if comp_neq == False:
    print("✓ Integer inequality (5 == 6): " + str(comp_neq));
    tests_passed = tests_passed + 1;
else:
    print("✗ Integer inequality (5 == 6): " + str(comp_neq));
    tests_failed = tests_failed + ["Integer inequality"];
end

total_tests = total_tests + 1;
let float_eq = 3.14 == 3.14;
if float_eq == True:
    print("✓ Float equality (3.14 == 3.14): " + str(float_eq));
    tests_passed = tests_passed + 1;
else:
    print("✗ Float equality (3.14 == 3.14): " + str(float_eq));
    tests_failed = tests_failed + ["Float equality"];
end

total_tests = total_tests + 1;
let str_eq = "hello" == "hello";
if str_eq == True:
    print("✓ String equality ('hello' == 'hello'): " + str(str_eq));
    tests_passed = tests_passed + 1;
else:
    print("✗ String equality ('hello' == 'hello'): " + str(str_eq));
    tests_failed = tests_failed + ["String equality"];
end

total_tests = total_tests + 1;
let bool_eq = True == True;
if bool_eq == True:
    print("✓ Boolean equality (True == True): " + str(bool_eq));
    tests_passed = tests_passed + 1;
else:
    print("✗ Boolean equality (True == True): " + str(bool_eq));
    tests_failed = tests_failed + ["Boolean equality"];
end

print("\n3.2. Inequality...");
total_tests = total_tests + 1;
let comp4 = 4 != 6;
if comp4 == True:
    print("✓ Integer inequality (4 != 6): " + str(comp4));
    tests_passed = tests_passed + 1;
else:
    print("✗ Integer inequality (4 != 6): " + str(comp4));
    tests_failed = tests_failed + ["Integer inequality"];
end

total_tests = total_tests + 1;
let str_neq = "hello" != "world";
if str_neq == True:
    print("✓ String inequality ('hello' != 'world'): " + str(str_neq));
    tests_passed = tests_passed + 1;
else:
    print("✗ String inequality ('hello' != 'world'): " + str(str_neq));
    tests_failed = tests_failed + ["String inequality"];
end

print("\n3.3. Greater than...");
total_tests = total_tests + 1;
let comp1 = 10 > 5;
if comp1 == True:
    print("✓ Greater than (10 > 5): " + str(comp1));
    tests_passed = tests_passed + 1;
else:
    print("✗ Greater than (10 > 5): " + str(comp1));
    tests_failed = tests_failed + ["Greater than"];
end

total_tests = total_tests + 1;
let comp1_false = 5 > 10;
if comp1_false == False:
    print("✓ Not greater than (5 > 10): " + str(comp1_false));
    tests_passed = tests_passed + 1;
else:
    print("✗ Not greater than (5 > 10): " + str(comp1_false));
    tests_failed = tests_failed + ["Not greater than"];
end

print("\n3.4. Less than...");
total_tests = total_tests + 1;
let comp2 = 3 < 7;
if comp2 == True:
    print("✓ Less than (3 < 7): " + str(comp2));
    tests_passed = tests_passed + 1;
else:
    print("✗ Less than (3 < 7): " + str(comp2));
    tests_failed = tests_failed + ["Less than"];
end

total_tests = total_tests + 1;
let comp2_false = 7 < 3;
if comp2_false == False:
    print("✓ Not less than (7 < 3): " + str(comp2_false));
    tests_passed = tests_passed + 1;
else:
    print("✗ Not less than (7 < 3): " + str(comp2_false));
    tests_failed = tests_failed + ["Not less than"];
end

print("\n3.5. Greater than or equal...");
total_tests = total_tests + 1;
let gte_true = 10 >= 5;
if gte_true == True:
    print("✓ Greater than or equal (10 >= 5): " + str(gte_true));
    tests_passed = tests_passed + 1;
else:
    print("✗ Greater than or equal (10 >= 5): " + str(gte_true));
    tests_failed = tests_failed + ["Greater than or equal"];
end

total_tests = total_tests + 1;
let gte_equal = 5 >= 5;
if gte_equal == True:
    print("✓ Equal values (5 >= 5): " + str(gte_equal));
    tests_passed = tests_passed + 1;
else:
    print("✗ Equal values (5 >= 5): " + str(gte_equal));
    tests_failed = tests_failed + ["Equal values"];
end

print("\n3.6. Less than or equal...");
total_tests = total_tests + 1;
let lte_true = 3 <= 7;
if lte_true == True:
    print("✓ Less than or equal (3 <= 7): " + str(lte_true));
    tests_passed = tests_passed + 1;
else:
    print("✗ Less than or equal (3 <= 7): " + str(lte_true));
    tests_failed = tests_failed + ["Less than or equal"];
end

total_tests = total_tests + 1;
let lte_equal = 5 <= 5;
if lte_equal == True:
    print("✓ Equal values (5 <= 5): " + str(lte_equal));
    tests_passed = tests_passed + 1;
else:
    print("✗ Equal values (5 <= 5): " + str(lte_equal));
    tests_failed = tests_failed + ["Equal values"];
end

print("\n=== 4. LOGICAL OPERATIONS ===");
print("4.1. Logical AND...");
total_tests = total_tests + 1;
let log1 = True and True;
if log1 == True:
    print("✓ Logical AND (True and True): " + str(log1));
    tests_passed = tests_passed + 1;
else:
    print("✗ Logical AND (True and True): " + str(log1));
    tests_failed = tests_failed + ["Logical AND"];
end

total_tests = total_tests + 1;
let log1_false = True and False;
if log1_false == False:
    print("✓ Logical AND false (True and False): " + str(log1_false));
    tests_passed = tests_passed + 1;
else:
    print("✗ Logical AND false (True and False): " + str(log1_false));
    tests_failed = tests_failed + ["Logical AND false"];
end

# Note: Symbolic && operator not yet implemented in Myco

print("\n4.2. Logical OR...");
total_tests = total_tests + 1;
let log2 = False or True;
if log2 == True:
    print("✓ Logical OR (False or True): " + str(log2));
    tests_passed = tests_passed + 1;
else:
    print("✗ Logical OR (False or True): " + str(log2));
    tests_failed = tests_failed + ["Logical OR"];
end

total_tests = total_tests + 1;
let log2_false = False or False;
if log2_false == False:
    print("✓ Logical OR false (False or False): " + str(log2_false));
    tests_passed = tests_passed + 1;
else:
    print("✗ Logical OR false (False or False): " + str(log2_false));
    tests_failed = tests_failed + ["Logical OR false"];
end

# Note: Symbolic || operator not yet implemented in Myco

print("\n4.3. Logical NOT...");
total_tests = total_tests + 1;
let log3 = not False;
if log3 == True:
    print("✓ Logical NOT (not False): " + str(log3));
    tests_passed = tests_passed + 1;
else:
    print("✗ Logical NOT (not False): " + str(log3));
    tests_failed = tests_failed + ["Logical NOT"];
end

total_tests = total_tests + 1;
let log3_false = not True;
if log3_false == False:
    print("✓ Logical NOT false (not True): " + str(log3_false));
    tests_passed = tests_passed + 1;
else:
    print("✗ Logical NOT false (not True): " + str(log3_false));
    tests_failed = tests_failed + ["Logical NOT false"];
end

# Note: Symbolic ! operator not yet implemented in Myco

print("\n4.4. Complex logical expressions...");
total_tests = total_tests + 1;
let complex_log = (True and False) or True;
if complex_log == True:
    print("✓ Complex logical ((True and False) or True): " + str(complex_log));
    tests_passed = tests_passed + 1;
else:
    print("✗ Complex logical ((True and False) or True): " + str(complex_log));
    tests_failed = tests_failed + ["Complex logical"];
end

total_tests = total_tests + 1;
let nested_not = not (True and False);
if nested_not == True:
    print("✓ Nested NOT (not (True and False)): " + str(nested_not));
    tests_passed = tests_passed + 1;
else:
    print("✗ Nested NOT (not (True and False)): " + str(nested_not));
    tests_failed = tests_failed + ["Nested NOT"];
end

print("\n5. Arrays...");
total_tests = total_tests + 1;
let arr = [1, 2, 3];
if len(arr) == 3:
    print("✓ Simple array: " + str(arr));
    tests_passed = tests_passed + 1;
else:
    print("✗ Simple array: " + str(arr));
    tests_failed = tests_failed + ["FAILED: Simple array"];
end

total_tests = total_tests + 1;
let nested = [[1, 2], [3, 4]];
if len(nested) == 2:
    print("✓ Nested array: " + str(nested));
    tests_passed = tests_passed + 1;
else:
    print("✗ Nested array: " + str(nested));
    tests_failed = tests_failed + ["FAILED: Nested array"];
end

total_tests = total_tests + 1;
let mixed = [1, "hello", True, [1, 2]];
if len(mixed) == 4:
    print("✓ Mixed type array: " + str(mixed));
    tests_passed = tests_passed + 1;
else:
    print("✗ Mixed type array: " + str(mixed));
    tests_failed = tests_failed + ["FAILED: Mixed type array"];
end

total_tests = total_tests + 1;
let empty = [];
if len(empty) == 0:
    print("✓ Empty array: " + str(empty));
    tests_passed = tests_passed + 1;
else:
    print("✗ Empty array: " + str(empty));
    tests_failed = tests_failed + ["FAILED: Empty array"];
end

print("\n6. String Operations...");
total_tests = total_tests + 1;
let str1 = "Hello";
let str2 = "World";
let combined = str1 + " " + str2;
print("✓ String concatenation: " + combined);
tests_passed = tests_passed + 1;

total_tests = total_tests + 1;
let num_str = str(42);
print("✓ Number to string: " + num_str);
tests_passed = tests_passed + 1;

total_tests = total_tests + 1;
let bool_str = str(True);
print("✓ Boolean to string: " + bool_str);
tests_passed = tests_passed + 1;

print("\n=== 7. STRING OPERATIONS ===");
print("7.1. String concatenation...");
total_tests = total_tests + 1;
let str1 = "Hello";
let str2 = "World";
let combined = str1 + " " + str2;
if combined == "Hello World":
    print("✓ String concatenation: " + combined);
    tests_passed = tests_passed + 1;
else:
    print("✗ String concatenation: " + combined);
    tests_failed = tests_failed + ["String concatenation"];
end

total_tests = total_tests + 1;
let num_str = str(42);
if num_str == "42":
    print("✓ Number to string: " + num_str);
    tests_passed = tests_passed + 1;
else:
    print("✗ Number to string: " + num_str);
    tests_failed = tests_failed + ["Number to string"];
end

total_tests = total_tests + 1;
let bool_str = str(True);
if bool_str == "True":
    print("✓ Boolean to string: " + bool_str);
    tests_passed = tests_passed + 1;
else:
    print("✗ Boolean to string: " + bool_str);
    tests_failed = tests_failed + ["Boolean to string"];
end

print("\n7.2. Escape sequences...");
total_tests = total_tests + 1;
let escaped = "Line 1\nLine 2\tTabbed";
if len(escaped) > 0:
    print("✓ Escape sequences work");
    tests_passed = tests_passed + 1;
else:
    print("✗ Escape sequences work");
    tests_failed = tests_failed + ["Escape sequences"];
end

total_tests = total_tests + 1;
let quoted_str = "He said \"Hello\"";
if quoted_str == "He said \"Hello\"":
    print("✓ Quoted string: " + quoted_str);
    tests_passed = tests_passed + 1;
else:
    print("✗ Quoted string: " + quoted_str);
    tests_failed = tests_failed + ["Quoted string"];
end

total_tests = total_tests + 1;
let backslash_str = "Path: C:\\Users\\Name";
if backslash_str == "Path: C:\\Users\\Name":
    print("✓ Backslash string: " + backslash_str);
    tests_passed = tests_passed + 1;
else:
    print("✗ Backslash string: " + backslash_str);
    tests_failed = tests_failed + ["Backslash string"];
end

print("\n8. Control Flow...");
total_tests = total_tests + 1;
if 10 > 5:
    print("✓ If statement works");
    tests_passed = tests_passed + 1;
else:
    print("✗ If statement");
    tests_failed = tests_failed + ["FAILED: If statement"];
end

total_tests = total_tests + 1;
if 3 < 2:
    print("✗ This should not print");
    tests_failed = tests_failed + ["FAILED: If statement"];
else:
    print("✓ Else statement works");
    tests_passed = tests_passed + 1;
end

total_tests = total_tests + 1;
if 1 > 2:
    print("✗ This should not print");
    tests_failed = tests_failed + ["FAILED: If statement"];
else if 2 > 1:
    print("✓ Else-if statement works");
    tests_passed = tests_passed + 1;
else:
    print("✗ This should not print");
    tests_failed = tests_failed + ["FAILED: If statement"];
end

print("\n9. Built-in Libraries...");
total_tests = total_tests + 1;
use math as math;
if type(math) == "Module" or math != Null:
    print("✓ Math library imported");
    tests_passed = tests_passed + 1;
else:
    print("✗ Math library import failed");
    tests_failed = tests_failed + ["Math library import"];
end

total_tests = total_tests + 1;
use string as string;
if type(string) == "Module" or string != Null:
    print("✓ String library imported");
    tests_passed = tests_passed + 1;
else:
    print("✗ String library import failed");
    tests_failed = tests_failed + ["String library import"];
end

total_tests = total_tests + 1;
use array as array;
if type(array) == "Module" or array != Null:
    print("✓ Array library imported");
    tests_passed = tests_passed + 1;
else:
    print("✗ Array library import failed");
    tests_failed = tests_failed + ["Array library import"];
end

total_tests = total_tests + 1;
use file as file;
if type(file) == "Object" or file != Null:
    print("✓ File library imported");
    tests_passed = tests_passed + 1;
else:
    print("✗ File library import failed");
    tests_failed = tests_failed + ["File library import"];
end

total_tests = total_tests + 1;
use dir as dir;
if type(dir) == "Object" or dir != Null:
    print("✓ Directory library imported");
    tests_passed = tests_passed + 1;
else:
    print("✗ Directory library import failed");
    tests_failed = tests_failed + ["Directory library import"];
end

total_tests = total_tests + 1;
use maps as maps;
if type(maps) == "Object" or maps != Null:
    print("✓ Maps library imported");
    tests_passed = tests_passed + 1;
else:
    print("✗ Maps library import failed");
    tests_failed = tests_failed + ["Maps library import"];
end

total_tests = total_tests + 1;
use sets as sets;
if type(sets) == "Object" or sets != Null:
    print("✓ Sets library imported");
    tests_passed = tests_passed + 1;
else:
    print("✗ Sets library import failed");
    tests_failed = tests_failed + ["Sets library import"];
end

total_tests = total_tests + 1;
use trees as trees;
if type(trees) == "Object" or trees != Null:
    print("✓ Trees library imported");
    tests_passed = tests_passed + 1;
else:
    print("✗ Trees library import failed");
    tests_failed = tests_failed + ["Trees library import"];
end

total_tests = total_tests + 1;
use graphs as graphs;
if type(graphs) == "Object" or graphs != Null:
    print("✓ Graphs library imported");
    tests_passed = tests_passed + 1;
else:
    print("✗ Graphs library import failed");
    tests_failed = tests_failed + ["Graphs library import"];
end

print("\n10. Math Library Functions...");
total_tests = total_tests + 1;
let pi_value = math.Pi;
print("✓ Math.Pi: " + str(pi_value));
tests_passed = tests_passed + 1;

total_tests = total_tests + 1;
let e_value = math.E;
print("✓ Math.E: " + str(e_value));
tests_passed = tests_passed + 1;

total_tests = total_tests + 1;
let abs_result = math.abs(-5);
print("✓ Math.abs(-5): " + str(abs_result));
tests_passed = tests_passed + 1;

total_tests = total_tests + 1;
let min_result = math.min(10, 5);
print("✓ Math.min(10, 5): " + str(min_result));
tests_passed = tests_passed + 1;

total_tests = total_tests + 1;
let max_result = math.max(10, 5);
print("✓ Math.max(10, 5): " + str(max_result));
tests_passed = tests_passed + 1;

total_tests = total_tests + 1;
let sqrt_result = math.sqrt(16);
print("✓ Math.sqrt(16): " + str(sqrt_result));
tests_passed = tests_passed + 1;

print("\n11. String Library Functions...");
total_tests = total_tests + 1;
let test_str = "hello world";
let upper_str = string.upper(test_str);
print("✓ String.upper('hello world'): " + upper_str);
tests_passed = tests_passed + 1;

total_tests = total_tests + 1;
let lower_str = string.lower("HELLO WORLD");
print("✓ String.lower('HELLO WORLD'): " + lower_str);
tests_passed = tests_passed + 1;

total_tests = total_tests + 1;
let trim_str = string.trim("  hello  ");
print("✓ String.trim('  hello  '): '" + trim_str + "'");
tests_passed = tests_passed + 1;

total_tests = total_tests + 1;
let len_result = len("hello");
print("✓ len('hello'): " + str(len_result));
tests_passed = tests_passed + 1;

print("\n12. Input Function...");
total_tests = total_tests + 1;
# Note: input() function is available but not tested interactively in automated tests
print("✓ Input function available (tested manually)");
tests_passed = tests_passed + 1;

print("\n13. Array Library Functions...");
total_tests = total_tests + 1;
print("✓ Array library imported successfully");
tests_passed = tests_passed + 1;

print("\n13.1. Enhanced Array Operations...");
total_tests = total_tests + 1;
let test_array = [1, 2, 3, 4, 5];
let joined_result = array.join(test_array, ", ");
if type(joined_result) == "String" and joined_result != Null:
    print("✓ array.join() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ array.join() failed");
    tests_failed = tests_failed + ["array.join()"];
end

total_tests = total_tests + 1;
let contains_result = array.contains(test_array, 3);
if contains_result == True:
    print("✓ array.contains() with existing value");
    tests_passed = tests_passed + 1;
else:
    print("✗ array.contains() with existing value failed");
    tests_failed = tests_failed + ["array.contains() existing"];
end

total_tests = total_tests + 1;
let contains_missing = array.contains(test_array, 6);
if contains_missing == False:
    print("✓ array.contains() with missing value");
    tests_passed = tests_passed + 1;
else:
    print("✗ array.contains() with missing value failed");
    tests_failed = tests_failed + ["array.contains() missing"];
end

total_tests = total_tests + 1;
let index_of_result = array.indexOf(test_array, 3);
if index_of_result == 2:
    print("✓ array.indexOf() with existing value");
    tests_passed = tests_passed + 1;
else:
    print("✗ array.indexOf() with existing value failed");
    tests_failed = tests_failed + ["array.indexOf() existing"];
end

total_tests = total_tests + 1;
let index_of_missing = array.indexOf(test_array, 6);
if index_of_missing == -1:
    print("✓ array.indexOf() with missing value");
    tests_passed = tests_passed + 1;
else:
    print("✗ array.indexOf() with missing value failed");
    tests_failed = tests_failed + ["array.indexOf() missing"];
end

total_tests = total_tests + 1;
let duplicates_array = [1, 2, 2, 3, 3, 3, 4];
let unique_result = array.unique(duplicates_array);
if type(unique_result) == "Array" and unique_result != Null:
    print("✓ array.unique() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ array.unique() failed");
    tests_failed = tests_failed + ["array.unique()"];
end

total_tests = total_tests + 1;
let array1 = [1, 2, 3];
let array2 = [4, 5, 6];
let concat_result = array.concat(array1, array2);
if type(concat_result) == "Array" and concat_result != Null:
    print("✓ array.concat() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ array.concat() failed");
    tests_failed = tests_failed + ["array.concat()"];
end

total_tests = total_tests + 1;
let slice_result = array.slice(test_array, 1, 4);
if type(slice_result) == "Array" and slice_result != Null:
    print("✓ array.slice() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ array.slice() failed");
    tests_failed = tests_failed + ["array.slice()"];
end

total_tests = total_tests + 1;
let fill_array = [];
array.fill(fill_array, "test", 3);
if type(fill_array) == "Array":
    print("✓ array.fill() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ array.fill() failed");
    tests_failed = tests_failed + ["array.fill()"];
end

print("\n14. File Library Functions...");
total_tests = total_tests + 1;
let test_content = "Hello, Myco File System!";
let write_result = file.write("test_file.txt", test_content);
if write_result == Null:
    print("✓ File write successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ File write failed");
    tests_failed = tests_failed + ["File write"];
end

total_tests = total_tests + 1;
let exists_result = file.exists("test_file.txt");
if exists_result == True:
    print("✓ File exists check successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ File exists check failed");
    tests_failed = tests_failed + ["File exists"];
end

total_tests = total_tests + 1;
let read_result = file.read("test_file.txt");
if read_result != Null and type(read_result) == "String":
    print("✓ File read successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ File read failed");
    tests_failed = tests_failed + ["File read"];
end

total_tests = total_tests + 1;
let delete_result = file.delete("test_file.txt");
if delete_result == Null:
    print("✓ File delete successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ File delete failed");
    tests_failed = tests_failed + ["File delete"];
end

print("\n15. Directory Library Functions...");
total_tests = total_tests + 1;
let current_dir = dir.current();
if current_dir != Null and type(current_dir) == "String":
    print("✓ Current directory successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ Current directory failed");
    tests_failed = tests_failed + ["Current directory"];
end

total_tests = total_tests + 1;
let files = dir.list(".");
if files != Null and type(files) == "Array":
    print("✓ Directory listing successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ Directory listing failed");
    tests_failed = tests_failed + ["Directory listing"];
end

total_tests = total_tests + 1;
let create_result = dir.create("test_dir");
if create_result == Null:
    print("✓ Directory creation successful");
    tests_passed = tests_passed + 1;
    
    # Test directory exists
    total_tests = total_tests + 1;
    let exists_result = dir.exists("test_dir");
    if exists_result == True:
        print("✓ Directory exists check successful");
        tests_passed = tests_passed + 1;
    else:
        print("✗ Directory exists check failed");
        tests_failed = tests_failed + ["Directory exists"];
    end
    
    # Clean up
    dir.remove("test_dir");
else:
    print("✗ Directory creation failed");
    tests_failed = tests_failed + ["Directory creation"];
end

print("\n16. Maps Library Functions...");
total_tests = total_tests + 1;
let test_map = {name: "Alice", age: 30, city: "NYC"};
let has_name = maps.has(test_map, "name");
if has_name == True:
    print("✓ maps.has() with existing key");
    tests_passed = tests_passed + 1;
else:
    print("✗ maps.has() with existing key failed");
    tests_failed = tests_failed + ["maps.has() existing key"];
end

total_tests = total_tests + 1;
let has_missing = maps.has(test_map, "salary");
if has_missing == False:
    print("✓ maps.has() with missing key");
    tests_passed = tests_passed + 1;
else:
    print("✗ maps.has() with missing key failed");
    tests_failed = tests_failed + ["maps.has() missing key"];
end

total_tests = total_tests + 1;
let map_size = maps.size(test_map);
if map_size == 3:
    print("✓ maps.size() returns correct count");
    tests_passed = tests_passed + 1;
else:
    print("✗ maps.size() failed: " + str(map_size));
    tests_failed = tests_failed + ["maps.size()"];
end

total_tests = total_tests + 1;
let map_keys = maps.keys(test_map);
if type(map_keys) == "Array" and map_keys != Null:
    print("✓ maps.keys() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ maps.keys() failed");
    tests_failed = tests_failed + ["maps.keys()"];
end

total_tests = total_tests + 1;
maps.delete(test_map, "city");
let size_after_delete = maps.size(test_map);
if size_after_delete >= 2:  # Should be 2 or original if delete doesn't work in place
    print("✓ maps.delete() executed");
    tests_passed = tests_passed + 1;
else:
    print("✗ maps.delete() failed");
    tests_failed = tests_failed + ["maps.delete()"];
end

total_tests = total_tests + 1;
let update_map = {salary: 50000, department: "Engineering"};
maps.update(test_map, update_map);
let size_after_update = maps.size(test_map);
if size_after_update >= 2:  # Should maintain or increase size
    print("✓ maps.update() executed");
    tests_passed = tests_passed + 1;
else:
    print("✗ maps.update() failed");
    tests_failed = tests_failed + ["maps.update()"];
end

total_tests = total_tests + 1;
maps.clear(test_map);
print("✓ maps.clear() executed");
tests_passed = tests_passed + 1;

print("\n17. Sets Library Functions...");
total_tests = total_tests + 1;
let test_set = {"apple", "banana", "cherry"};
let has_apple = sets.has(test_set, "apple");
if has_apple == True:
    print("✓ sets.has() with existing element");
    tests_passed = tests_passed + 1;
else:
    print("✗ sets.has() with existing element failed");
    tests_failed = tests_failed + ["sets.has() existing element"];
end

total_tests = total_tests + 1;
let has_orange = sets.has(test_set, "orange");
if has_orange == False:
    print("✓ sets.has() with missing element");
    tests_passed = tests_passed + 1;
else:
    print("✗ sets.has() with missing element failed");
    tests_failed = tests_failed + ["sets.has() missing element"];
end

total_tests = total_tests + 1;
let set_size = sets.size(test_set);
if set_size == 3:
    print("✓ sets.size() returns correct count");
    tests_passed = tests_passed + 1;
else:
    print("✗ sets.size() failed: " + str(set_size));
    tests_failed = tests_failed + ["sets.size()"];
end

total_tests = total_tests + 1;
sets.add(test_set, "orange");
let size_after_add = sets.size(test_set);
if size_after_add >= 3:  # Should be 4 or original if add doesn't work in place
    print("✓ sets.add() executed");
    tests_passed = tests_passed + 1;
else:
    print("✗ sets.add() failed");
    tests_failed = tests_failed + ["sets.add()"];
end

total_tests = total_tests + 1;
sets.remove(test_set, "banana");
let size_after_remove = sets.size(test_set);
if size_after_remove >= 2:  # Should be 3 or less if remove works
    print("✓ sets.remove() executed");
    tests_passed = tests_passed + 1;
else:
    print("✗ sets.remove() failed");
    tests_failed = tests_failed + ["sets.remove()"];
end

total_tests = total_tests + 1;
let set_to_array = sets.toArray(test_set);
if type(set_to_array) == "Array" and set_to_array != Null:
    print("✓ sets.toArray() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ sets.toArray() failed");
    tests_failed = tests_failed + ["sets.toArray()"];
end

total_tests = total_tests + 1;
let other_set = {"grape", "orange", "kiwi"};
let union_result = sets.union(test_set, other_set);
if type(union_result) == "Set" and union_result != Null:
    print("✓ sets.union() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ sets.union() failed");
    tests_failed = tests_failed + ["sets.union()"];
end

total_tests = total_tests + 1;
let intersection_result = sets.intersection(test_set, other_set);
if type(intersection_result) == "Set" and intersection_result != Null:
    print("✓ sets.intersection() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ sets.intersection() failed");
    tests_failed = tests_failed + ["sets.intersection()"];
end

total_tests = total_tests + 1;
let clear_result = sets.clear(test_set);
if clear_result == Null:
    print("✓ sets.clear() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ sets.clear() failed");
    tests_failed = tests_failed + ["sets.clear()"];
end

print("\n18. Trees Library Functions...");
total_tests = total_tests + 1;
let test_tree = trees.create();
if type(test_tree) == "Object" and test_tree != Null:
    print("✓ trees.create() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ trees.create() failed");
    tests_failed = tests_failed + ["trees.create()"];
end

total_tests = total_tests + 1;
let tree_size = trees.size(test_tree);
if tree_size == 0:
    print("✓ trees.size() returns correct initial size");
    tests_passed = tests_passed + 1;
else:
    print("✗ trees.size() failed: " + str(tree_size));
    tests_failed = tests_failed + ["trees.size()"];
end

total_tests = total_tests + 1;
let tree_is_empty = trees.isEmpty(test_tree);
if tree_is_empty == True:
    print("✓ trees.isEmpty() returns correct initial state");
    tests_passed = tests_passed + 1;
else:
    print("✗ trees.isEmpty() failed");
    tests_failed = tests_failed + ["trees.isEmpty()"];
end

total_tests = total_tests + 1;
let tree_insert = trees.insert(test_tree, "root");
if type(tree_insert) == "String" and tree_insert != Null:
    print("✓ trees.insert() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ trees.insert() failed");
    tests_failed = tests_failed + ["trees.insert()"];
end

total_tests = total_tests + 1;
let tree_search = trees.search(test_tree, "root");
if type(tree_search) == "Boolean":
    print("✓ trees.search() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ trees.search() failed");
    tests_failed = tests_failed + ["trees.search()"];
end

total_tests = total_tests + 1;
let tree_clear = trees.clear(test_tree);
if tree_clear == Null:
    print("✓ trees.clear() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ trees.clear() failed");
    tests_failed = tests_failed + ["trees.clear()"];
end

print("\n19. Graphs Library Functions...");
total_tests = total_tests + 1;
let test_graph = graphs.create(False);  # Undirected graph
if type(test_graph) == "Object" and test_graph != Null:
    print("✓ graphs.create() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ graphs.create() failed");
    tests_failed = tests_failed + ["graphs.create()"];
end

total_tests = total_tests + 1;
let graph_size = graphs.size(test_graph);
if graph_size == 0:
    print("✓ graphs.size() returns correct initial size");
    tests_passed = tests_passed + 1;
else:
    print("✗ graphs.size() failed: " + str(graph_size));
    tests_failed = tests_failed + ["graphs.size()"];
end

total_tests = total_tests + 1;
let graph_is_empty = graphs.isEmpty(test_graph);
if graph_is_empty == True:
    print("✓ graphs.isEmpty() returns correct initial state");
    tests_passed = tests_passed + 1;
else:
    print("✗ graphs.isEmpty() failed");
    tests_failed = tests_failed + ["graphs.isEmpty()"];
end

total_tests = total_tests + 1;
let graph_add_node = graphs.addNode(test_graph, "node1");
if type(graph_add_node) == "String" and graph_add_node != Null:
    print("✓ graphs.addNode() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ graphs.addNode() failed");
    tests_failed = tests_failed + ["graphs.addNode()"];
end

total_tests = total_tests + 1;
let graph_add_edge = graphs.addEdge(test_graph, "node1", "node2");
if type(graph_add_edge) == "String" and graph_add_edge != Null:
    print("✓ graphs.addEdge() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ graphs.addEdge() failed");
    tests_failed = tests_failed + ["graphs.addEdge()"];
end

total_tests = total_tests + 1;
let graph_clear = graphs.clear(test_graph);
if graph_clear == Null:
    print("✓ graphs.clear() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ graphs.clear() failed");
    tests_failed = tests_failed + ["graphs.clear()"];
end

total_tests = total_tests + 1;
let directed_graph = graphs.create(True);  # Directed graph
if type(directed_graph) == "Object" and directed_graph != Null:
    print("✓ graphs.create() with directed parameter successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ graphs.create() with directed parameter failed");
    tests_failed = tests_failed + ["graphs.create() directed"];
end

print("\n20. Heaps Library Functions...");
total_tests = total_tests + 1;
let test_heap = heaps.create(True);  # Max heap
if type(test_heap) == "Object" and test_heap != Null:
    print("✓ heaps.create() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ heaps.create() failed");
    tests_failed = tests_failed + ["heaps.create()"];
end

total_tests = total_tests + 1;
let heap_size = heaps.size(test_heap);
if heap_size == 0:
    print("✓ heaps.size() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ heaps.size() failed");
    tests_failed = tests_failed + ["heaps.size()"];
end

total_tests = total_tests + 1;
let heap_empty = heaps.isEmpty(test_heap);
if heap_empty == True:
    print("✓ heaps.isEmpty() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ heaps.isEmpty() failed");
    tests_failed = tests_failed + ["heaps.isEmpty()"];
end

total_tests = total_tests + 1;
test_heap = heaps.insert(test_heap, 10);
test_heap = heaps.insert(test_heap, 5);
test_heap = heaps.insert(test_heap, 15);
let heap_size_after = heaps.size(test_heap);
if heap_size_after == 3:
    print("✓ heaps.insert() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ heaps.insert() failed");
    tests_failed = tests_failed + ["heaps.insert()"];
end

total_tests = total_tests + 1;
let heap_peek = heaps.peek(test_heap);
if heap_peek == 15:  # Max heap should have 15 at root
    print("✓ heaps.peek() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ heaps.peek() failed");
    tests_failed = tests_failed + ["heaps.peek()"];
end

total_tests = total_tests + 1;
test_heap = heaps.extract(test_heap);  # Get new heap after extraction
let heap_size_after_extract = heaps.size(test_heap);
if heap_size_after_extract == 2:  # Should have 2 elements left (10, 5)
    print("✓ heaps.extract() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ heaps.extract() failed");
    tests_failed = tests_failed + ["heaps.extract()"];
end

total_tests = total_tests + 1;
test_heap = heaps.clear(test_heap);
let heap_clear_size = heaps.size(test_heap);
if heap_clear_size == 0:
    print("✓ heaps.clear() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ heaps.clear() failed");
    tests_failed = tests_failed + ["heaps.clear()"];
end

print("\n21. Queues Library Functions...");
total_tests = total_tests + 1;
let test_queue = queues.create();
if type(test_queue) == "Object" and test_queue != Null:
    print("✓ queues.create() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ queues.create() failed");
    tests_failed = tests_failed + ["queues.create()"];
end

total_tests = total_tests + 1;
let queue_size = queues.size(test_queue);
if queue_size == 0:
    print("✓ queues.size() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ queues.size() failed");
    tests_failed = tests_failed + ["queues.size()"];
end

total_tests = total_tests + 1;
let queue_empty = queues.isEmpty(test_queue);
if queue_empty == True:
    print("✓ queues.isEmpty() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ queues.isEmpty() failed");
    tests_failed = tests_failed + ["queues.isEmpty()"];
end

total_tests = total_tests + 1;
test_queue = queues.enqueue(test_queue, "first");
test_queue = queues.enqueue(test_queue, "second");
test_queue = queues.enqueue(test_queue, "third");
let queue_size_after = queues.size(test_queue);
if queue_size_after == 3:
    print("✓ queues.enqueue() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ queues.enqueue() failed");
    tests_failed = tests_failed + ["queues.enqueue()"];
end

total_tests = total_tests + 1;
let queue_front = queues.front(test_queue);
if queue_front == "first":
    print("✓ queues.front() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ queues.front() failed");
    tests_failed = tests_failed + ["queues.front()"];
end

total_tests = total_tests + 1;
let queue_back = queues.back(test_queue);
if queue_back == "third":
    print("✓ queues.back() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ queues.back() failed");
    tests_failed = tests_failed + ["queues.back()"];
end

total_tests = total_tests + 1;
test_queue = queues.dequeue(test_queue);  # Get new queue after dequeue
let queue_size_after_dequeue = queues.size(test_queue);
if queue_size_after_dequeue == 2:  # Should have 2 elements left ("second", "third")
    print("✓ queues.dequeue() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ queues.dequeue() failed");
    tests_failed = tests_failed + ["queues.dequeue()"];
end

total_tests = total_tests + 1;
test_queue = queues.clear(test_queue);
let queue_clear_size = queues.size(test_queue);
if queue_clear_size == 0:
    print("✓ queues.clear() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ queues.clear() failed");
    tests_failed = tests_failed + ["queues.clear()"];
end

print("\n22. Stacks Library Functions...");
total_tests = total_tests + 1;
let test_stack = stacks.create();
if type(test_stack) == "Object" and test_stack != Null:
    print("✓ stacks.create() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ stacks.create() failed");
    tests_failed = tests_failed + ["stacks.create()"];
end

total_tests = total_tests + 1;
let stack_size = stacks.size(test_stack);
if stack_size == 0:
    print("✓ stacks.size() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ stacks.size() failed");
    tests_failed = tests_failed + ["stacks.size()"];
end

total_tests = total_tests + 1;
let stack_empty = stacks.isEmpty(test_stack);
if stack_empty == True:
    print("✓ stacks.isEmpty() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ stacks.isEmpty() failed");
    tests_failed = tests_failed + ["stacks.isEmpty()"];
end

total_tests = total_tests + 1;
test_stack = stacks.push(test_stack, "bottom");
test_stack = stacks.push(test_stack, "middle");
test_stack = stacks.push(test_stack, "top");
let stack_size_after = stacks.size(test_stack);
if stack_size_after == 3:
    print("✓ stacks.push() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ stacks.push() failed");
    tests_failed = tests_failed + ["stacks.push()"];
end

total_tests = total_tests + 1;
let stack_top = stacks.top(test_stack);
if stack_top == "top":
    print("✓ stacks.top() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ stacks.top() failed");
    tests_failed = tests_failed + ["stacks.top()"];
end

total_tests = total_tests + 1;
test_stack = stacks.pop(test_stack);  # Get new stack after pop
let stack_size_after_pop = stacks.size(test_stack);
if stack_size_after_pop == 2:  # Should have 2 elements left ("bottom", "middle")
    print("✓ stacks.pop() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ stacks.pop() failed");
    tests_failed = tests_failed + ["stacks.pop()"];
end

total_tests = total_tests + 1;
test_stack = stacks.clear(test_stack);
let stack_clear_size = stacks.size(test_stack);
if stack_clear_size == 0:
    print("✓ stacks.clear() successful");
    tests_passed = tests_passed + 1;
else:
    print("✗ stacks.clear() failed");
    tests_failed = tests_failed + ["stacks.clear()"];
end

print("\n=== 23. BUILT-IN FUNCTIONS ===");
print("20.1. Type checking...");
total_tests = total_tests + 1;
let type_result = type(42);
if type_result == "Int":
    print("✓ type(42): " + type_result);
    tests_passed = tests_passed + 1;
else:
    print("✗ type(42): " + type_result);
    tests_failed = tests_failed + ["type(42)"];
end

total_tests = total_tests + 1;
let type_float = type(3.14);
if type_float == "Float":
    print("✓ type(3.14): " + type_float);
    tests_passed = tests_passed + 1;
else:
    print("✗ type(3.14): " + type_float);
    tests_failed = tests_failed + ["type(3.14)"];
end

total_tests = total_tests + 1;
let type_str = type("hello");
if type_str == "String":
    print("✓ type('hello'): " + type_str);
    tests_passed = tests_passed + 1;
else:
    print("✗ type('hello'): " + type_str);
    tests_failed = tests_failed + ["type('hello')"];
end

total_tests = total_tests + 1;
let type_bool = type(True);
if type_bool == "Boolean":
    print("✓ type(True): " + type_bool);
    tests_passed = tests_passed + 1;
else:
    print("✗ type(True): " + type_bool);
    tests_failed = tests_failed + ["type(True)"];
end

total_tests = total_tests + 1;
let type_null = type(Null);
if type_null == "Null":
    print("✓ type(Null): " + type_null);
    tests_passed = tests_passed + 1;
else:
    print("✗ type(Null): " + type_null);
    tests_failed = tests_failed + ["type(Null)"];
end

total_tests = total_tests + 1;
let type_array = type([1, 2, 3]);
if type_array == "Array":
    print("✓ type([1,2,3]): " + type_array);
    tests_passed = tests_passed + 1;
else:
    print("✗ type([1,2,3]): " + type_array);
    tests_failed = tests_failed + ["type([1,2,3])"];
end

print("\n13.2. Length function...");
total_tests = total_tests + 1;
let len_builtin = len("hello");
if len_builtin == 5:
    print("✓ len('hello'): " + str(len_builtin));
    tests_passed = tests_passed + 1;
else:
    print("✗ len('hello'): " + str(len_builtin));
    tests_failed = tests_failed + ["len('hello')"];
end

total_tests = total_tests + 1;
let len_empty = len("");
if len_empty == 0:
    print("✓ len(''): " + str(len_empty));
    tests_passed = tests_passed + 1;
else:
    print("✗ len(''): " + str(len_empty));
    tests_failed = tests_failed + ["len('')"];
end

total_tests = total_tests + 1;
let len_array = len([1, 2, 3]);
if len_array == 3:
    print("✓ len([1,2,3]): " + str(len_array));
    tests_passed = tests_passed + 1;
else:
    print("✗ len([1,2,3]): " + str(len_array));
    tests_failed = tests_failed + ["len([1,2,3])"];
end

print("\n13.3. String conversion...");
total_tests = total_tests + 1;
let str_builtin = str(3.14);
if str_builtin == "3.140000":
    print("✓ str(3.14): " + str_builtin);
    tests_passed = tests_passed + 1;
else:
    print("✗ str(3.14): " + str_builtin);
    tests_failed = tests_failed + ["str(3.14)"];
end

total_tests = total_tests + 1;
let str_bool = str(False);
if str_bool == "False":
    print("✓ str(False): " + str_bool);
    tests_passed = tests_passed + 1;
else:
    print("✗ str(False): " + str_bool);
    tests_failed = tests_failed + ["str(False)"];
end

total_tests = total_tests + 1;
let str_null = str(Null);
if str_null == "Null":
    print("✓ str(Null): " + str_null);
    tests_passed = tests_passed + 1;
else:
    print("✗ str(Null): " + str_null);
    tests_failed = tests_failed + ["str(Null)"];
end

total_tests = total_tests + 1;
let str_array = str([1, 2, 3]);
if str_array == "[1, 2, 3]":
    print("✓ str([1,2,3]): " + str_array);
    tests_passed = tests_passed + 1;
else:
    print("✗ str([1,2,3]): " + str_array);
    tests_failed = tests_failed + ["str([1,2,3])"];
end

print("\n=== 14. EDGE CASES ===");
print("14.1. Zero and negative numbers...");
total_tests = total_tests + 1;
let zero_add = 0 + 0;
if zero_add == 0:
    print("✓ Zero addition (0 + 0): " + str(zero_add));
    tests_passed = tests_passed + 1;
else:
    print("✗ Zero addition (0 + 0): " + str(zero_add));
    tests_failed = tests_failed + ["Zero addition"];
end

total_tests = total_tests + 1;
let zero_mult = 0 * 5;
if zero_mult == 0:
    print("✓ Zero multiplication (0 * 5): " + str(zero_mult));
    tests_passed = tests_passed + 1;
else:
    print("✗ Zero multiplication (0 * 5): " + str(zero_mult));
    tests_failed = tests_failed + ["Zero multiplication"];
end

total_tests = total_tests + 1;
let neg_add = -5 + 3;
if neg_add == -2:
    print("✓ Negative addition (-5 + 3): " + str(neg_add));
    tests_passed = tests_passed + 1;
else:
    print("✗ Negative addition (-5 + 3): " + str(neg_add));
    tests_failed = tests_failed + ["Negative addition"];
end

print("\n14.2. Large numbers...");
total_tests = total_tests + 1;
let large_add = 999999 + 1;
if large_add == 1000000:
    print("✓ Large addition (999999 + 1): " + str(large_add));
    tests_passed = tests_passed + 1;
else:
    print("✗ Large addition (999999 + 1): " + str(large_add));
    tests_failed = tests_failed + ["Large addition"];
end

total_tests = total_tests + 1;
let large_mult = 1000 * 1000;
if large_mult == 1000000:
    print("✓ Large multiplication (1000 * 1000): " + str(large_mult));
    tests_passed = tests_passed + 1;
else:
    print("✗ Large multiplication (1000 * 1000): " + str(large_mult));
    tests_failed = tests_failed + ["Large multiplication"];
end

print("\n14.3. Floating point precision...");
total_tests = total_tests + 1;
let float_prec = 0.1 + 0.2;
if float_prec > 0.3:
    print("✓ Float precision (0.1 + 0.2 > 0.3): " + str(float_prec));
    tests_passed = tests_passed + 1;
else:
    print("✗ Float precision (0.1 + 0.2 > 0.3): " + str(float_prec));
    tests_failed = tests_failed + ["Float precision"];
end

total_tests = total_tests + 1;
let float_eq = 1.0 == 1;
if float_eq == True:
    print("✓ Float equality (1.0 == 1): " + str(float_eq));
    tests_passed = tests_passed + 1;
else:
    print("✗ Float equality (1.0 == 1): " + str(float_eq));
    tests_failed = tests_failed + ["Float equality"];
end

print("\n14.4. Empty values...");
total_tests = total_tests + 1;
let empty_str_len = len("");
if empty_str_len == 0:
    print("✓ Empty string length: " + str(empty_str_len));
    tests_passed = tests_passed + 1;
else:
    print("✗ Empty string length: " + str(empty_str_len));
    tests_failed = tests_failed + ["Empty string length"];
end

total_tests = total_tests + 1;
let empty_array_len = len([]);
if empty_array_len == 0:
    print("✓ Empty array length: " + str(empty_array_len));
    tests_passed = tests_passed + 1;
else:
    print("✗ Empty array length: " + str(empty_array_len));
    tests_failed = tests_failed + ["Empty array length"];
end

total_tests = total_tests + 1;
let empty_concat = "" + "hello";
if empty_concat == "hello":
    print("✓ Empty string concatenation: " + empty_concat);
    tests_passed = tests_passed + 1;
else:
    print("✗ Empty string concatenation: " + empty_concat);
    tests_failed = tests_failed + ["Empty string concatenation"];
end

print("\n=== 15. ERROR HANDLING (Expected Errors) ===");
print("15.1. Division by zero (should continue execution)...");
total_tests = total_tests + 1;
let div_by_zero = 10 / 0;
# Check that execution continues and we get a reasonable result (likely 0 or null)
if div_by_zero == 0 or div_by_zero == Null or type(div_by_zero) == "Number":
    print("✓ Division by zero handled gracefully");
    tests_passed = tests_passed + 1;
else:
    print("✗ Division by zero not handled properly");
    tests_failed = tests_failed + ["Division by zero handling"];
end

print("\n15.2. Array index out of bounds (should continue execution)...");
total_tests = total_tests + 1;
let test_arr = [1, 2, 3];
let out_of_bounds = test_arr[10];
# Check that execution continues and we get a reasonable result
if out_of_bounds == Null or out_of_bounds == 0 or type(out_of_bounds) == "Number":
    print("✓ Array out of bounds handled gracefully");
    tests_passed = tests_passed + 1;
else:
    print("✗ Array out of bounds not handled properly");
    tests_failed = tests_failed + ["Array out of bounds handling"];
end

print("\n15.3. Undefined variable (should continue execution)...");
total_tests = total_tests + 1;
let undefined_var = non_existent_variable;
# Check that execution continues and we get a reasonable result
if undefined_var == Null or type(undefined_var) == "String":
    print("✓ Undefined variable handled gracefully");
    tests_passed = tests_passed + 1;
else:
    print("✗ Undefined variable not handled properly");
    tests_failed = tests_failed + ["Undefined variable handling"];
end

print("\n16.1. Function definitions (no parameters, no return type)...");
func simple_greet():
    print("Hello from simple function!");
end

total_tests = total_tests + 1;
if type(simple_greet) == "Function":
    print("✓ Simple function definition (no params, no return)");
    tests_passed = tests_passed + 1;
else:
    print("✗ Simple function definition failed");
    tests_failed = tests_failed + ["Simple function definition"];
end

print("\n16.2. Function with single parameter (no return type)...");
func greet_with_name(name):
    print("Hello, " + name + "!");
end

total_tests = total_tests + 1;
if type(greet_with_name) == "Function":
    print("✓ Function with single parameter (no return type)");
    tests_passed = tests_passed + 1;
else:
    print("✗ Function with single parameter failed");
    tests_failed = tests_failed + ["Function with single parameter"];
end

print("\n16.3. Function with multiple parameters (no return type)...");
func add_numbers(a, b):
    let result = a + b;
    print("Sum: " + str(result));
end

total_tests = total_tests + 1;
if type(add_numbers) == "Function":
    print("✓ Function with multiple parameters (no return type)");
    tests_passed = tests_passed + 1;
else:
    print("✗ Function with multiple parameters failed");
    tests_failed = tests_failed + ["Function with multiple parameters"];
end

print("\n16.4. Function definitions (with return types)...");
func get_pi() -> Number:
    return 3.14159;
end

func multiply(x, y) -> Number:
    return x * y;
end

func get_greeting(name) -> String:
    return "Hello, " + name + "!";
end

total_tests = total_tests + 1;
if type(get_pi) == "Function" and type(multiply) == "Function" and type(get_greeting) == "Function":
    print("✓ Function definitions with return types");
    tests_passed = tests_passed + 1;
else:
    print("✗ Function definitions with return types failed");
    tests_failed = tests_failed + ["Function definitions with return types"];
end

print("\n16.4. Function definitions (mixed explicit/implicit types)...");
func mixed_func1(x, y: Number) -> String:
    return "Mixed types: " + str(x) + ", " + str(y);
end

func mixed_func2(name: String):
    print("Name: " + name);
end

func mixed_func3(a, b) -> Number:
    return a + b;
end

total_tests = total_tests + 1;
if type(mixed_func1) == "Function" and type(mixed_func2) == "Function" and type(mixed_func3) == "Function":
    print("✓ Function definitions with mixed explicit/implicit types");
    tests_passed = tests_passed + 1;
else:
    print("✗ Function definitions with mixed types failed");
    tests_failed = tests_failed + ["Function definitions with mixed types"];
end

print("\n16.5. Function calls (no parameters)...");
func return_five() -> Number:
    return 5;
end

func return_hello() -> String:
    return "Hello";
end

total_tests = total_tests + 1;
let five = return_five();
let hello = return_hello();
if five == 5 and hello == "Hello":
    print("✓ Function calls with no parameters");
    tests_passed = tests_passed + 1;
else:
    print("✗ Function calls with no parameters failed");
    tests_failed = tests_failed + ["Function calls with no parameters"];
end

print("\n16.6. Function calls (with parameters)...");
func add(a, b) -> Number:
    return a + b;
end

func concatenate(str1, str2) -> String:
    return str1 + str2;
end

total_tests = total_tests + 1;
let sum = add(10, 20);
let combined = concatenate("Hello", "World");
if sum == 30 and combined == "HelloWorld":
    print("✓ Function calls with parameters");
    tests_passed = tests_passed + 1;
else:
    print("✗ Function calls with parameters failed");
    tests_failed = tests_failed + ["Function calls with parameters"];
end

print("\n16.7. Function calls (with type annotations)...");
func typed_add(x: Number, y: Number) -> Number:
    return x + y;
end

func typed_greet(name: String) -> String:
    return "Hello, " + name;
end

total_tests = total_tests + 1;
let typed_sum = typed_add(5, 15);
let typed_greeting = typed_greet("Myco");
if typed_sum == 20 and typed_greeting == "Hello, Myco":
    print("✓ Function calls with type annotations");
    tests_passed = tests_passed + 1;
else:
    print("✗ Function calls with type annotations failed");
    tests_failed = tests_failed + ["Function calls with type annotations"];
end

print("\n16.8. Recursive functions...");
func factorial(n) -> Number:
    if n <= 1:
        return 1;
    else:
        return n * factorial(n - 1);
    end
end

func fibonacci(n) -> Number:
    if n <= 1:
        return n;
    else:
        return fibonacci(n - 1) + fibonacci(n - 2);
    end
end

total_tests = total_tests + 1;
let fact_5 = factorial(5);
let fib_7 = fibonacci(7);
if fact_5 == 120 and fib_7 == 13:
    print("✓ Recursive functions");
    tests_passed = tests_passed + 1;
else:
    print("✗ Recursive functions failed");
    tests_failed = tests_failed + ["Recursive functions"];
end

print("\n16.9. Function variables and assignments...");
func square(x) -> Number:
    return x * x;
end

let my_square = square;
let my_add = add;

total_tests = total_tests + 1;
if type(my_square) == "Function" and type(my_add) == "Function":
    let square_result = my_square(4);
    let add_result = my_add(3, 7);
    if square_result == 16 and add_result == 10:
        print("✓ Function variables and assignments");
        tests_passed = tests_passed + 1;
    else:
        print("✗ Function variables and assignments failed");
        tests_failed = tests_failed + ["Function variables and assignments"];
    end
else:
    print("✗ Function variables and assignments failed");
    tests_failed = tests_failed + ["Function variables and assignments"];
end

print("\n16.10. Complex function combinations...");
func math_operations(a, b) -> Array:
    let results = [];
    results = array.push(results, add(a, b));
    results = array.push(results, multiply(a, b));
    results = array.push(results, square(a));
    results = array.push(results, square(b));
    return results;
end

func process_strings(str1, str2) -> String:
    let combined = concatenate(str1, str2);
    let greeting = typed_greet(combined);
    return greeting;
end

total_tests = total_tests + 1;
let math_results = math_operations(3, 4);
let string_result = process_strings("Myco", "Lang");
if len(math_results) == 4 and string_result == "Hello, MycoLang":
    print("✓ Complex function combinations");
    tests_passed = tests_passed + 1;
else:
    print("✗ Complex function combinations failed");
    tests_failed = tests_failed + ["Complex function combinations"];
end

print("\n16.11. Function scope and closures...");
func create_counter() -> Function:
    let count = 0;
    func counter() -> Number:
        count = count + 1;
        return count;
    end
    return counter;
end

total_tests = total_tests + 1;
let counter1 = create_counter();
let counter2 = create_counter();
if type(counter1) == "Function" and type(counter2) == "Function":
    let count1 = counter1();
    let count2 = counter1();
    let count3 = counter2();
    if count1 == 1 and count2 == 2 and count3 == 1:
        print("✓ Function scope and closures");
        tests_passed = tests_passed + 1;
    else:
        print("✗ Function scope and closures failed");
        tests_failed = tests_failed + ["Function scope and closures"];
    end
else:
    print("✗ Function scope and closures failed");
    tests_failed = tests_failed + ["Function scope and closures"];
end

print("\n16.12. Function error handling...");
func safe_divide(a, b) -> Number:
    if b == 0:
        return 0;
    else:
        return a / b;
    end
end

func safe_array_access(arr, index) -> String:
    if index >= len(arr):
        return "Index out of bounds";
    else:
        return str(arr[index]);
    end
end

total_tests = total_tests + 1;
let div_by_zero = safe_divide(10, 0);
let safe_access = safe_array_access([1, 2, 3], 5);
if div_by_zero == 0 and safe_access == "Index out of bounds":
    print("✓ Function error handling");
    tests_passed = tests_passed + 1;
else:
    print("✗ Function error handling failed");
    tests_failed = tests_failed + ["Function error handling"];
end

print("\n16.13. Lambda functions (anonymous functions)...");
let simple_lambda = func ():
    return "Hello from lambda!";
end;

let add_lambda = func (a, b):
    return a + b;
end;

let multiply_lambda = func (x, y) -> Number:
    return x * y;
end;

let greet_lambda = func (name):
    return "Hello, " + name + "!";
end;

let mixed_lambda = func (x, y: Number) -> String:
    return "Mixed: " + str(x) + " and " + str(y);
end;

total_tests = total_tests + 1;
if type(simple_lambda) == "Function" and type(add_lambda) == "Function" and 
   type(multiply_lambda) == "Function" and type(greet_lambda) == "Function" and 
   type(mixed_lambda) == "Function":
    print("✓ Lambda functions (anonymous functions)");
    tests_passed = tests_passed + 1;
else:
    print("✗ Lambda functions (anonymous functions) failed");
    tests_failed = tests_failed + ["Lambda functions (anonymous functions)"];
end

print("\n16.14. Function variable assignments...");
let my_square = func (x):
    return x * x;
end;

let my_add = func (a, b):
    return a + b;
end;

let my_greet = func (name):
    return "Hello, " + name + "!";
end;

total_tests = total_tests + 1;
if type(my_square) == "Function" and type(my_add) == "Function" and type(my_greet) == "Function":
    print("✓ Function variable assignments");
    tests_passed = tests_passed + 1;
else:
    print("✗ Function variable assignments failed");
    tests_failed = tests_failed + ["Function variable assignments"];
end

print("\n16.15. Lambda functions with different parameter types...");
let no_params_lambda = func ():
    return 42;
end;

let single_param_lambda = func (x):
    return x * 2;
end;

let multi_param_lambda = func (a, b, c):
    return a + b + c;
end;

let typed_param_lambda = func (x: Number, y: Number) -> Number:
    return x * y;
end;

total_tests = total_tests + 1;
if type(no_params_lambda) == "Function" and type(single_param_lambda) == "Function" and 
   type(multi_param_lambda) == "Function" and type(typed_param_lambda) == "Function":
    print("✓ Lambda functions with different parameter types");
    tests_passed = tests_passed + 1;
else:
    print("✗ Lambda functions with different parameter types failed");
    tests_failed = tests_failed + ["Lambda functions with different parameter types"];
end

print("\n16.16. Explicit function with all types...");
func explicit_all(param: Int) -> String:
    return str(param);
end

total_tests = total_tests + 1;
if type(explicit_all) == "Function":
    let result = explicit_all(42);
    if result != Null:
        print("✓ Explicit function with all types");
        tests_passed = tests_passed + 1;
    else:
        print("✗ Explicit function with all types failed");
        tests_failed = tests_failed + ["Explicit function with all types"];
    end
else:
    print("✗ Explicit function with all types failed");
    tests_failed = tests_failed + ["Explicit function with all types"];
end

print("\n16.17. Implicit function with no types...");
func implicit_none(param):
    return str(param);
end

total_tests = total_tests + 1;
if type(implicit_none) == "Function":
    let result = implicit_none(42);
    if result != Null:
        print("✓ Implicit function with no types");
        tests_passed = tests_passed + 1;
    else:
        print("✗ Implicit function with no types failed");
        tests_failed = tests_failed + ["Implicit function with no types"];
    end
else:
    print("✗ Implicit function with no types failed");
    tests_failed = tests_failed + ["Implicit function with no types"];
end

print("\n16.18. Mixed function - explicit parameter, implicit return...");
func mixed_param(param: Int):
    return str(param);
end

total_tests = total_tests + 1;
if type(mixed_param) == "Function":
    let result = mixed_param(42);
    if result != Null:
        print("✓ Mixed function - explicit parameter, implicit return");
        tests_passed = tests_passed + 1;
    else:
        print("✗ Mixed function - explicit parameter, implicit return failed");
        tests_failed = tests_failed + ["Mixed function - explicit parameter, implicit return"];
    end
else:
    print("✗ Mixed function - explicit parameter, implicit return failed");
    tests_failed = tests_failed + ["Mixed function - explicit parameter, implicit return"];
end

print("\n16.19. Mixed function - implicit parameter, explicit return...");
func mixed_return(param) -> String:
    return str(param);
end

total_tests = total_tests + 1;
if type(mixed_return) == "Function":
    let result = mixed_return(42);
    if result != Null:
        print("✓ Mixed function - implicit parameter, explicit return");
        tests_passed = tests_passed + 1;
    else:
        print("✗ Mixed function - implicit parameter, explicit return failed");
        tests_failed = tests_failed + ["Mixed function - implicit parameter, explicit return"];
    end
else:
    print("✗ Mixed function - implicit parameter, explicit return failed");
    tests_failed = tests_failed + ["Mixed function - implicit parameter, explicit return"];
end

print("\n16.20. Function variable with explicit types...");
let explicit_var: Function = func (param: Int) -> String:
    return str(param);
end;

total_tests = total_tests + 1;
if type(explicit_var) == "Function":
    let result = explicit_var(42);
    if result != Null:
        print("✓ Function variable with explicit types");
        tests_passed = tests_passed + 1;
    else:
        print("✗ Function variable with explicit types failed");
        tests_failed = tests_failed + ["Function variable with explicit types"];
    end
else:
    print("✗ Function variable with explicit types failed");
    tests_failed = tests_failed + ["Function variable with explicit types"];
end

print("\n16.21. Function variable with implicit types...");
let implicit_var = func (param):
    return str(param);
end;

total_tests = total_tests + 1;
if type(implicit_var) == "Function":
    let result = implicit_var(42);
    if result != Null:
        print("✓ Function variable with implicit types");
        tests_passed = tests_passed + 1;
    else:
        print("✗ Function variable with implicit types failed");
        tests_failed = tests_failed + ["Function variable with implicit types"];
    end
else:
    print("✗ Function variable with implicit types failed");
    tests_failed = tests_failed + ["Function variable with implicit types"];
end

print("\n16.22. Function variable with mixed types...");
let mixed_var: Function = func (param: Int):
    return str(param);
end;

total_tests = total_tests + 1;
if type(mixed_var) == "Function":
    let result = mixed_var(42);
    if result != Null:
        print("✓ Function variable with mixed types");
        tests_passed = tests_passed + 1;
    else:
        print("✗ Function variable with mixed types failed");
        tests_failed = tests_failed + ["Function variable with mixed types"];
    end
else:
    print("✗ Function variable with mixed types failed");
    tests_failed = tests_failed + ["Function variable with mixed types"];
end

print("\n16.23. Function variable with mixed return type...");
let mixed_return_var = func (param) -> String:
    return str(param);
end;

total_tests = total_tests + 1;
if type(mixed_return_var) == "Function":
    let result = mixed_return_var(42);
    if result != Null:
        print("✓ Function variable with mixed return type");
        tests_passed = tests_passed + 1;
    else:
        print("✗ Function variable with mixed return type failed");
        tests_failed = tests_failed + ["Function variable with mixed return type"];
    end
else:
    print("✗ Function variable with mixed return type failed");
    tests_failed = tests_failed + ["Function variable with mixed return type"];
end

print("\n16.24. Function type interchangeability with different argument types...");
total_tests = total_tests + 1;
# Test that all functions work with different argument types
let test_int = 42;
let test_string = "hello";
let test_bool = True;

# Test with integer
let int_result1 = explicit_all(test_int);
let int_result2 = implicit_none(test_int);
let int_result3 = mixed_param(test_int);
let int_result4 = mixed_return(test_int);
let int_result5 = explicit_var(test_int);
let int_result6 = implicit_var(test_int);
let int_result7 = mixed_var(test_int);
let int_result8 = mixed_return_var(test_int);

# Test with string
let string_result1 = explicit_all(test_string);
let string_result2 = implicit_none(test_string);
let string_result3 = mixed_param(test_string);
let string_result4 = mixed_return(test_string);
let string_result5 = explicit_var(test_string);
let string_result6 = implicit_var(test_string);
let string_result7 = mixed_var(test_string);
let string_result8 = mixed_return_var(test_string);

# Test with boolean
let bool_result1 = explicit_all(test_bool);
let bool_result2 = implicit_none(test_bool);
let bool_result3 = mixed_param(test_bool);
let bool_result4 = mixed_return(test_bool);
let bool_result5 = explicit_var(test_bool);
let bool_result6 = implicit_var(test_bool);
let bool_result7 = mixed_var(test_bool);
let bool_result8 = mixed_return_var(test_bool);

# Check that all results are valid (not Null)
if int_result1 != Null and int_result2 != Null and int_result3 != Null and int_result4 != Null and
   int_result5 != Null and int_result6 != Null and int_result7 != Null and int_result8 != Null and
   string_result1 != Null and string_result2 != Null and string_result3 != Null and string_result4 != Null and
   string_result5 != Null and string_result6 != Null and string_result7 != Null and string_result8 != Null and
   bool_result1 != Null and bool_result2 != Null and bool_result3 != Null and bool_result4 != Null and
   bool_result5 != Null and bool_result6 != Null and bool_result7 != Null and bool_result8 != Null:
    print("✓ Function type interchangeability with different argument types");
    tests_passed = tests_passed + 1;
else:
    print("✗ Function type interchangeability with different argument types failed");
    tests_failed = tests_failed + ["Function type interchangeability with different argument types"];
end

# 17. Classes and Objects
total_tests = total_tests + 1;
class TestClass:
    let name: String
end
# Test that we can actually instantiate the class
let test_instance = TestClass("TestName");
if type(test_instance) == "TestClass" and test_instance.name == "TestName":
    print("✓ Basic class parsing");
    tests_passed = tests_passed + 1;
else:
    print("✗ Basic class parsing failed");
    tests_failed = tests_failed + ["Basic class parsing"];
end

total_tests = total_tests + 1;
class Person:
    let name: String
    let age: Int
end
# Test that we can actually instantiate the class with multiple fields
let person_instance = Person("Alice", 30);
if type(person_instance) == "Person" and person_instance.name == "Alice" and person_instance.age == 30:
    print("✓ Class with typed fields");
    tests_passed = tests_passed + 1;
else:
    print("✗ Class with typed fields failed");
    tests_failed = tests_failed + ["Class with typed fields"];
end

total_tests = total_tests + 1;
class DefaultClass:
    let name = "Default"
    let count = 0
end
# Test that default values are actually set
let default_instance = DefaultClass();
if type(default_instance) == "DefaultClass" and default_instance.name == "Default" and default_instance.count == 0:
    print("✓ Class with default field values");
    tests_passed = tests_passed + 1;
else:
    print("✗ Class with default field values failed");
    tests_failed = tests_failed + ["Class with default field values"];
end

total_tests = total_tests + 1;
class SimpleClass:
    let value: Int
end
let s: SimpleClass = SimpleClass(42);
if type(s) == "SimpleClass" and s.value == 42:
    print("✓ Class instantiation");
    tests_passed = tests_passed + 1;
else:
    print("✗ Class instantiation failed");
    tests_failed = tests_failed + ["Class instantiation"];
end

total_tests = total_tests + 1;
class MethodClass:
    let name: String
    func greet() -> String:
        return "Hello, " + self.name
    end
end
let m: MethodClass = MethodClass("World");
# Test that the method actually works
let greeting = m.greet();
if type(m) == "MethodClass" and greeting == "Hello, World":
    print("✓ Class with methods");
    tests_passed = tests_passed + 1;
else:
    print("✗ Class with methods failed");
    tests_failed = tests_failed + ["Class with methods"];
end

total_tests = total_tests + 1;
class SelfClass:
    let value: Int
    func getValue() -> Int:
        return self.value
    end
end
let self_test: SelfClass = SelfClass(100);
# Test that self references work
let retrieved_value = self_test.getValue();
if type(self_test) == "SelfClass" and retrieved_value == 100:
    print("✓ Class with self references");
    tests_passed = tests_passed + 1;
else:
    print("✗ Class with self references failed");
    tests_failed = tests_failed + ["Class with self references"];
end

total_tests = total_tests + 1;
class MixedClass:
    let name: String
    let age: Int
    let active = true
end
let mixed: MixedClass = MixedClass("Alice", 25);
# Test that mixed field types work
if type(mixed) == "MixedClass" and mixed.name == "Alice" and mixed.age == 25 and mixed.active == true:
    print("✓ Class with mixed field types");
    tests_passed = tests_passed + 1;
else:
    print("✗ Class with mixed field types failed");
    tests_failed = tests_failed + ["Class with mixed field types"];
end

total_tests = total_tests + 1;
class TypedMethodClass:
    let count: Int
    func increment() -> Int:
        return self.count + 1
    end
    func getName() -> String:
        return "TypedMethodClass"
    end
end
let typed: TypedMethodClass = TypedMethodClass(5);
# Test that typed methods work
let incremented = typed.increment();
let class_name = typed.getName();
if type(typed) == "TypedMethodClass" and incremented == 6 and class_name == "TypedMethodClass":
    print("✓ Class with typed methods");
    tests_passed = tests_passed + 1;
else:
    print("✗ Class with typed methods failed");
    tests_failed = tests_failed + ["Class with typed methods"];
end

total_tests = total_tests + 1;
class UntypedMethodClass:
    let data: String
    func process():
        # Method without return type
    end
end
let untyped: UntypedMethodClass = UntypedMethodClass("data");
# Test that untyped methods work (they should return null)
let result = untyped.process();
if type(untyped) == "UntypedMethodClass" and (result == Null or result == 0):
    print("✓ Class with untyped methods");
    tests_passed = tests_passed + 1;
else:
    print("✗ Class with untyped methods failed");
    tests_failed = tests_failed + ["Class with untyped methods"];
end

total_tests = total_tests + 1;
class ComplexClass:
    let x: Int
    let y: Int
    func calculate() -> Int:
        if self.x > self.y:
            return self.x * 2
        else:
            return self.y * 2
        end
    end
end
let complex: ComplexClass = ComplexClass(10, 5);
# Test that complex method bodies work
let calculation = complex.calculate();
if type(complex) == "ComplexClass" and calculation == 20:  # 10 > 5, so 10 * 2 = 20
    print("✓ Class with complex method bodies");
    tests_passed = tests_passed + 1;
else:
    print("✗ Class with complex method bodies failed");
    tests_failed = tests_failed + ["Class with complex method bodies"];
end

# 17. INHERITANCE TESTS
print("\n=== 17. INHERITANCE TESTS ===");

# 17.1. Basic inheritance parsing
class Animal:
    let name: String
    func speak() -> String:
        return "Some sound"
    end
end

class Dog extends Animal:
    func speak() -> String:
        return "Woof!"
    end
end
# Test that inheritance actually works by creating a Dog instance
let test_dog = Dog("Rex");
if type(test_dog) == "Dog" and test_dog.name == "Rex":
    print("✓ Basic inheritance parsing");
    total_tests = total_tests + 1;
    tests_passed = tests_passed + 1;
else:
    print("✗ Basic inheritance parsing failed");
    total_tests = total_tests + 1;
    tests_failed = tests_failed + ["Basic inheritance parsing"];
end

# 17.2. Field inheritance
let dog: Dog = Dog("Buddy");
if dog.name == "Buddy":
    print("✓ Field inheritance");
    tests_passed = tests_passed + 1;
else:
    print("✗ Field inheritance");
    tests_failed = tests_failed + [17.2];
end

# 17.3. Method overriding
total_tests = total_tests + 1;
# Note: Method calls are now working, so we can test the actual functionality
let sound: String = dog.speak();
if sound == "Woof!":
    print("✓ Method overriding");
    tests_passed = tests_passed + 1;
else:
    print("✗ Method overriding");
    tests_failed = tests_failed + ["Method overriding"];
end

# 17.4. Multi-level inheritance
class Puppy extends Dog:
    let age: Int
    func speak() -> String:
        return "Yip!"
    end
end
# Test that multi-level inheritance actually works
let test_puppy = Puppy("Max", 6);
if type(test_puppy) == "Puppy" and test_puppy.name == "Max" and test_puppy.age == 6:
    print("✓ Multi-level inheritance parsing");
    total_tests = total_tests + 1;
    tests_passed = tests_passed + 1;
else:
    print("✗ Multi-level inheritance parsing failed");
    total_tests = total_tests + 1;
    tests_failed = tests_failed + ["Multi-level inheritance parsing"];
end

# 17.5. Inheritance with additional fields
let puppy: Puppy = Puppy("Max", 6);
if puppy.name == "Max":
    print("✓ Inheritance with additional fields");
    tests_passed = tests_passed + 1;
else:
    print("✗ Inheritance with additional fields");
    tests_failed = tests_failed + [17.5];
end

# 17.6. Inheritance without method override
class Cat extends Animal:
    let color: String
end
# Test that inheritance without method override works
let test_cat = Cat("Whiskers", "Orange");
if type(test_cat) == "Cat" and test_cat.name == "Whiskers" and test_cat.color == "Orange":
    print("✓ Inheritance without method override");
    total_tests = total_tests + 1;
    tests_passed = tests_passed + 1;
else:
    print("✗ Inheritance without method override failed");
    total_tests = total_tests + 1;
    tests_failed = tests_failed + ["Inheritance without method override"];
end

# 17.7. Complex inheritance chain
class WildAnimal extends Animal:
    let habitat: String
    func roar() -> String:
        return "ROAR!"
    end
end

class Lion extends WildAnimal:
    let mane_color: String
    func roar() -> String:
        return "LION ROAR!"
    end
end
# Test that complex inheritance chain works
let test_lion = Lion("Simba", "Savanna", "Golden");
if type(test_lion) == "Lion" and test_lion.name == "Simba" and test_lion.habitat == "Savanna" and test_lion.mane_color == "Golden":
    print("✓ Complex inheritance chain");
    total_tests = total_tests + 1;
    tests_passed = tests_passed + 1;
else:
    print("✗ Complex inheritance chain failed");
    total_tests = total_tests + 1;
    tests_failed = tests_failed + ["Complex inheritance chain"];
end

# 17.8. Inheritance with default values
class Bird extends Animal:
    let can_fly = true
    let wing_span: Float
end
print("✓ Inheritance with default values");
total_tests = total_tests + 1;

# 17.9. Multiple inheritance simulation (not supported, but test structure)
class FlyingAnimal extends Animal:
    let altitude: Int
    func fly() -> String:
        return "Flying high!"
    end
end
print("✓ Multiple inheritance simulation");
total_tests = total_tests + 1;

# 17.10. Inheritance with mixed field types
class Fish extends Animal:
    let species: String
    let depth = 0
    let is_saltwater: Boolean
end
print("✓ Inheritance with mixed field types");
total_tests = total_tests + 1;
tests_passed = tests_passed + 1;

# 23. Time Library Functions
print("\n=== 23. Time Library Functions ===");

# Test time library import
use time as time;
total_tests = total_tests + 1;
if type(time) == "Object":
    print("✓ Time library import works");
    tests_passed = tests_passed + 1;
else:
    print("✗ Time library import failed");
end

# Test time.now()
total_tests = total_tests + 1;
let current_time = time.now();
if type(current_time) == "Object":
    print("✓ time.now() returns time object");
    tests_passed = tests_passed + 1;
else:
    print("✗ time.now() failed");
end

# Test time.create()
total_tests = total_tests + 1;
let specific_time = time.create(2024, 1, 15, 14, 30, 0);
if type(specific_time) == "Object":
    print("✓ time.create() returns time object");
    tests_passed = tests_passed + 1;
else:
    print("✗ time.create() failed");
end

# Test time.format()
total_tests = total_tests + 1;
let formatted = time.format(specific_time, "%Y-%m-%d %H:%M:%S");
if formatted == "2024-01-15 14:30:00":
    print("✓ time.format() works correctly");
    tests_passed = tests_passed + 1;
else:
    print("✗ time.format() failed");
end

# Test time.year()
total_tests = total_tests + 1;
let year = time.year(specific_time);
if year == 2024:
    print("✓ time.year() works correctly");
    tests_passed = tests_passed + 1;
else:
    print("✗ time.year() failed");
end

# Test time.month()
total_tests = total_tests + 1;
let month = time.month(specific_time);
if month == 1:
    print("✓ time.month() works correctly");
    tests_passed = tests_passed + 1;
else:
    print("✗ time.month() failed");
end

# Test time.day()
total_tests = total_tests + 1;
let day = time.day(specific_time);
if day == 15:
    print("✓ time.day() works correctly");
    tests_passed = tests_passed + 1;
else:
    print("✗ time.day() failed");
end

# Test time.hour()
total_tests = total_tests + 1;
let hour = time.hour(specific_time);
if hour == 14:
    print("✓ time.hour() works correctly");
    tests_passed = tests_passed + 1;
else:
    print("✗ time.hour() failed");
end

# Test time.minute()
total_tests = total_tests + 1;
let minute = time.minute(specific_time);
if minute == 30:
    print("✓ time.minute() works correctly");
    tests_passed = tests_passed + 1;
else:
    print("✗ time.minute() failed");
end

# Test time.second()
total_tests = total_tests + 1;
let second = time.second(specific_time);
if second == 0:
    print("✓ time.second() works correctly");
    tests_passed = tests_passed + 1;
else:
    print("✗ time.second() failed");
end

# Test time.iso_string()
total_tests = total_tests + 1;
let iso = time.iso_string(specific_time);
if iso == "2024-01-15T14:30:00":
    print("✓ time.iso_string() works correctly");
    tests_passed = tests_passed + 1;
else:
    print("✗ time.iso_string() failed");
end

# Test time.unix_timestamp()
total_tests = total_tests + 1;
let unix = time.unix_timestamp(specific_time);
if unix == 1705347000:
    print("✓ time.unix_timestamp() works correctly");
    tests_passed = tests_passed + 1;
else:
    print("✗ time.unix_timestamp() failed");
end

# Test time.add()
total_tests = total_tests + 1;
let future_time = time.add(specific_time, 3600);
let future_hour = time.hour(future_time);
if future_hour == 15:
    print("✓ time.add() works correctly");
    tests_passed = tests_passed + 1;
else:
    print("✗ time.add() failed");
end

# Test time.subtract()
total_tests = total_tests + 1;
let past_time = time.subtract(specific_time, 3600);
let past_hour = time.hour(past_time);
if past_hour == 13:
    print("✓ time.subtract() works correctly");
    tests_passed = tests_passed + 1;
else:
    print("✗ time.subtract() failed");
end

# Test time.difference()
total_tests = total_tests + 1;
let time1 = time.create(2024, 1, 15, 15, 0, 0);
let time2 = time.create(2024, 1, 15, 14, 0, 0);
let diff = time.difference(time1, time2);
if diff == 3600:
    print("✓ time.difference() works correctly");
    tests_passed = tests_passed + 1;
else:
    print("✗ time.difference() failed");
end

# 24. Regex Library Functions
print("\n=== 24. Regex Library Functions ===");

# Test regex library import
use regex as regex;
total_tests = total_tests + 1;
if type(regex) == "Object":
    print("✓ Regex library import works");
    tests_passed = tests_passed + 1;
else:
    print("✗ Regex library import failed");
    tests_failed = tests_failed + ["Regex library import"];
end

# Test regex.match() - basic matching
total_tests = total_tests + 1;
let match_result = regex.match("hello", "hello world");
if type(match_result) == "Object" and match_result != Null:
    print("✓ regex.match() returns match object");
    tests_passed = tests_passed + 1;
else:
    print("✗ regex.match() failed");
    tests_failed = tests_failed + ["regex.match()"];
end

# Test regex.match() - no match
total_tests = total_tests + 1;
let no_match = regex.match("xyz", "hello world");
if no_match == Null:
    print("✓ regex.match() returns Null for no match");
    tests_passed = tests_passed + 1;
else:
    print("✗ regex.match() should return Null for no match");
    tests_failed = tests_failed + ["regex.match() no match"];
end

# Test regex.test() - basic testing
total_tests = total_tests + 1;
let test_result = regex.test("world", "hello world");
if test_result == True:
    print("✓ regex.test() works for existing pattern");
    tests_passed = tests_passed + 1;
else:
    print("✗ regex.test() failed for existing pattern");
    tests_failed = tests_failed + ["regex.test() existing"];
end

# Test regex.test() - no match
total_tests = total_tests + 1;
let test_no_match = regex.test("xyz", "hello world");
if test_no_match == False:
    print("✓ regex.test() works for non-existing pattern");
    tests_passed = tests_passed + 1;
else:
    print("✗ regex.test() failed for non-existing pattern");
    tests_failed = tests_failed + ["regex.test() non-existing"];
end

# Test regex.is_email() - valid email
total_tests = total_tests + 1;
let valid_email = regex.is_email("test@example.com");
if valid_email == True:
    print("✓ regex.is_email() works for valid email");
    tests_passed = tests_passed + 1;
else:
    print("✗ regex.is_email() failed for valid email");
    tests_failed = tests_failed + ["regex.is_email() valid"];
end

# Test regex.is_email() - invalid email
total_tests = total_tests + 1;
let invalid_email = regex.is_email("not-an-email");
if invalid_email == False:
    print("✓ regex.is_email() works for invalid email");
    tests_passed = tests_passed + 1;
else:
    print("✗ regex.is_email() failed for invalid email");
    tests_failed = tests_failed + ["regex.is_email() invalid"];
end

# Test regex.is_url() - valid URL
total_tests = total_tests + 1;
let valid_url = regex.is_url("https://example.com");
if valid_url == True:
    print("✓ regex.is_url() works for valid URL");
    tests_passed = tests_passed + 1;
else:
    print("✗ regex.is_url() failed for valid URL");
    tests_failed = tests_failed + ["regex.is_url() valid"];
end

# Test regex.is_url() - invalid URL
total_tests = total_tests + 1;
let invalid_url = regex.is_url("not-a-url");
if invalid_url == False:
    print("✓ regex.is_url() works for invalid URL");
    tests_passed = tests_passed + 1;
else:
    print("✗ regex.is_url() failed for invalid URL");
    tests_failed = tests_failed + ["regex.is_url() invalid"];
end

# Test regex.is_ip() - valid IP
total_tests = total_tests + 1;
let valid_ip = regex.is_ip("192.168.1.1");
if valid_ip == True:
    print("✓ regex.is_ip() works for valid IP");
    tests_passed = tests_passed + 1;
else:
    print("✗ regex.is_ip() failed for valid IP");
    tests_failed = tests_failed + ["regex.is_ip() valid"];
end

# Test regex.is_ip() - invalid IP
total_tests = total_tests + 1;
let invalid_ip = regex.is_ip("not-an-ip");
if invalid_ip == False:
    print("✓ regex.is_ip() works for invalid IP");
    tests_passed = tests_passed + 1;
else:
    print("✗ regex.is_ip() failed for invalid IP");
    tests_failed = tests_failed + ["regex.is_ip() invalid"];
end

# Test regex flags - CASE_INSENSITIVE
total_tests = total_tests + 1;
let case_test = regex.test("HELLO", "hello world", regex.CASE_INSENSITIVE);
if case_test == True:
    print("✓ regex.CASE_INSENSITIVE flag works");
    tests_passed = tests_passed + 1;
else:
    print("✗ regex.CASE_INSENSITIVE flag failed");
    tests_failed = tests_failed + ["regex.CASE_INSENSITIVE"];
end

# Test regex flags - GLOBAL
total_tests = total_tests + 1;
let global_test = regex.test("l", "hello", regex.GLOBAL);
if global_test == True:
    print("✓ regex.GLOBAL flag works");
    tests_passed = tests_passed + 1;
else:
    print("✗ regex.GLOBAL flag failed");
    tests_failed = tests_failed + ["regex.GLOBAL"];
end

# Test regex flags - MULTILINE
total_tests = total_tests + 1;
let multiline_test = regex.test("^world", "hello\nworld", regex.MULTILINE);
if multiline_test == True:
    print("✓ regex.MULTILINE flag works");
    tests_passed = tests_passed + 1;
else:
    print("✗ regex.MULTILINE flag failed");
    tests_failed = tests_failed + ["regex.MULTILINE"];
end

# Test regex flags - DOTALL
total_tests = total_tests + 1;
let dotall_test = regex.test("hello.world", "hello\nworld", regex.DOTALL);
if dotall_test == True:
    print("✓ regex.DOTALL flag works");
    tests_passed = tests_passed + 1;
else:
    print("✗ regex.DOTALL flag failed");
    tests_failed = tests_failed + ["regex.DOTALL"];
end

# Test complex regex patterns
total_tests = total_tests + 1;
let complex_pattern = regex.test("[0-9]+", "123abc");
if complex_pattern == True:
    print("✓ Complex regex patterns work");
    tests_passed = tests_passed + 1;
else:
    print("✗ Complex regex patterns failed");
    tests_failed = tests_failed + ["Complex regex patterns"];
end

# Test regex with special characters
total_tests = total_tests + 1;
let special_chars = regex.test("[a-zA-Z0-9_]+", "hello123");
if special_chars == True:
    print("✓ Regex with special characters works");
    tests_passed = tests_passed + 1;
else:
    print("✗ Regex with special characters failed");
    tests_failed = tests_failed + ["Regex special characters"];
end

# Test multiple email formats
total_tests = total_tests + 1;
let email1 = regex.is_email("user@domain.com");
let email2 = regex.is_email("test.email+tag@example.co.uk");
let email3 = regex.is_email("invalid@");
let email4 = regex.is_email("@domain.com");
if email1 == True and email2 == True and email3 == False and email4 == False:
    print("✓ Multiple email format validation works");
    tests_passed = tests_passed + 1;
else:
    print("✗ Multiple email format validation failed");
    tests_failed = tests_failed + ["Multiple email formats"];
end

# Test multiple URL formats
total_tests = total_tests + 1;
let url1 = regex.is_url("http://example.com");
let url2 = regex.is_url("https://www.example.com/path");
let url3 = regex.is_url("ftp://files.example.com");
let url4 = regex.is_url("not-a-url");
if url1 == True and url2 == True and url3 == True and url4 == False:
    print("✓ Multiple URL format validation works");
    tests_passed = tests_passed + 1;
else:
    print("✗ Multiple URL format validation failed");
    tests_failed = tests_failed + ["Multiple URL formats"];
end

# Test multiple IP formats
total_tests = total_tests + 1;
let ip1 = regex.is_ip("192.168.1.1");
let ip2 = regex.is_ip("10.0.0.1");
let ip3 = regex.is_ip("255.255.255.255");
let ip4 = regex.is_ip("999.999.999.999");
if ip1 == True and ip2 == True and ip3 == True and ip4 == False:
    print("✓ Multiple IP format validation works");
    tests_passed = tests_passed + 1;
else:
    print("✗ Multiple IP format validation failed");
    tests_failed = tests_failed + ["Multiple IP formats"];
end

# Test regex error handling
total_tests = total_tests + 1;
let invalid_pattern = regex.test("[", "test");
# Should handle invalid regex gracefully
if type(invalid_pattern) == "Boolean":
    print("✓ Regex error handling works");
    tests_passed = tests_passed + 1;
else:
    print("✗ Regex error handling failed");
    tests_failed = tests_failed + ["Regex error handling"];
end

# Test regex with empty strings
total_tests = total_tests + 1;
let empty_match = regex.match("", "hello");
let empty_test = regex.test("", "hello");
if (type(empty_match) == "Object" or empty_match == Null) and type(empty_test) == "Boolean":
    print("✓ Regex with empty strings works");
    tests_passed = tests_passed + 1;
else:
    print("✗ Regex with empty strings failed");
    tests_failed = tests_failed + ["Regex empty strings"];
end

# 25. JSON Library Functions
print("\n=== 25. JSON Library Functions ===");

# Test JSON library import
use json as json;
total_tests = total_tests + 1;
if type(json) == "Object":
    print("✓ JSON library import works");
    tests_passed = tests_passed + 1;
else:
    print("✗ JSON library import failed");
    tests_failed = tests_failed + ["JSON library import"];
end

# Test json.stringify() - basic types
total_tests = total_tests + 1;
let str_result = json.stringify("hello");
if str_result == "\"hello\"":
    print("✓ json.stringify() works for strings");
    tests_passed = tests_passed + 1;
else:
    print("✗ json.stringify() failed for strings");
    tests_failed = tests_failed + ["json.stringify() strings"];
end

total_tests = total_tests + 1;
let num_result = json.stringify(42);
if num_result == "42":
    print("✓ json.stringify() works for numbers");
    tests_passed = tests_passed + 1;
else:
    print("✗ json.stringify() failed for numbers");
    tests_failed = tests_failed + ["json.stringify() numbers"];
end

total_tests = total_tests + 1;
let bool_result = json.stringify(True);
if bool_result == "true":
    print("✓ json.stringify() works for booleans");
    tests_passed = tests_passed + 1;
else:
    print("✗ json.stringify() failed for booleans");
    tests_failed = tests_failed + ["json.stringify() booleans"];
end

total_tests = total_tests + 1;
let null_result = json.stringify(Null);
if null_result == "null":
    print("✓ json.stringify() works for null");
    tests_passed = tests_passed + 1;
else:
    print("✗ json.stringify() failed for null");
    tests_failed = tests_failed + ["json.stringify() null"];
end

# Test json.stringify() - arrays
total_tests = total_tests + 1;
let arr = [1, 2, 3, "hello", true];
let arr_result = json.stringify(arr);
if type(arr_result) == "String" and arr_result != "":
    print("✓ json.stringify() works for arrays");
    tests_passed = tests_passed + 1;
else:
    print("✗ json.stringify() failed for arrays");
    tests_failed = tests_failed + ["json.stringify() arrays"];
end

# Test json.validate() - valid JSON
total_tests = total_tests + 1;
let valid_json = '{"test": "value"}';
let is_valid = json.validate(valid_json);
if is_valid == True:
    print("✓ json.validate() works for valid JSON");
    tests_passed = tests_passed + 1;
else:
    print("✗ json.validate() failed for valid JSON");
    tests_failed = tests_failed + ["json.validate() valid"];
end

# Test json.validate() - invalid JSON
total_tests = total_tests + 1;
let invalid_json = '{"test": "value"';
let is_invalid = json.validate(invalid_json);
if is_invalid == False:
    print("✓ json.validate() works for invalid JSON");
    tests_passed = tests_passed + 1;
else:
    print("✗ json.validate() failed for invalid JSON");
    tests_failed = tests_failed + ["json.validate() invalid"];
end

# Test json.size() - arrays
total_tests = total_tests + 1;
let test_array = [1, 2, 3, 4, 5];
let array_size = json.size(test_array);
if array_size == 5:
    print("✓ json.size() works for arrays");
    tests_passed = tests_passed + 1;
else:
    print("✗ json.size() failed for arrays");
    tests_failed = tests_failed + ["json.size() arrays"];
end

# Test json.is_empty() - arrays
total_tests = total_tests + 1;
let empty_array = [];
let non_empty_array = [1, 2, 3];
let empty_check = json.is_empty(empty_array);
let non_empty_check = json.is_empty(non_empty_array);
if empty_check == True and non_empty_check == False:
    print("✓ json.is_empty() works for arrays");
    tests_passed = tests_passed + 1;
else:
    print("✗ json.is_empty() failed for arrays");
    tests_failed = tests_failed + ["json.is_empty() arrays"];
end

# Test json.parse() - basic functionality
total_tests = total_tests + 1;
let parsed = json.parse('{"test": "value"}');
if type(parsed) == "Object":
    print("✓ json.parse() works");
    tests_passed = tests_passed + 1;
else:
    print("✗ json.parse() failed");
    tests_failed = tests_failed + ["json.parse()"];
end



# Nothing After This Pointer
# Below Are The Results, Never Change
# Put Any Additions Above These Three Lines

print("\n=== RESULTS ===");
print("Total: " + str(total_tests));
print("Passed: " + str(tests_passed));
print("Failed: " + str(total_tests - tests_passed));


let rate = (tests_passed * 100) / total_tests;
print("Success rate: " + str(rate) + "%");

if total_tests - tests_passed > 0:
    print("Failed tests:");
    
    for i in tests_failed:
        print("\t - ", i);
    end
else:
    print("ALL TESTS PASSED!");
end