# Performance Benchmark: Bytecode VM vs AST Interpreter

print("=== Myco Performance Benchmark ===");
print("");

# Test 1: Arithmetic Operations (Pure bytecode)
print("Test 1: Arithmetic Operations");
let start_time = 0;
let sum = 0;
let i = 0;

# Warm up
while i < 1000:
    sum = sum + i;
    i = i + 1;
end

# Reset for actual test
sum = 0;
i = 0;

# 10M arithmetic operations
while i < 10000000:
    sum = sum + i * 2 + 1;
    i = i + 1;
end

print("Arithmetic completed: " + sum.toString());
print("");

# Test 2: Function Calls (Bytecode with some AST fallback)
print("Test 2: Function Calls");

func recursive_fib(n: Int) -> Int:
    if n <= 1:
        return n;
    else:
        return recursive_fib(n - 1) + recursive_fib(n - 2);
    end
end

func iterative_fib(n: Int) -> Int:
    if n <= 1:
        return n;
    end
    
    let a = 0;
    let b = 1;
    let i = 2;
    
    while i <= n:
        let temp = a + b;
        a = b;
        b = temp;
        i = i + 1;
    end
    
    return b;
end

# Test recursive (slower, more function calls)
let fib_rec = recursive_fib(25);
print("Recursive Fibonacci(25): " + fib_rec.toString());

# Test iterative (faster, fewer function calls)
let fib_iter = iterative_fib(25);
print("Iterative Fibonacci(25): " + fib_iter.toString());
print("");

# Test 3: Array Operations (Pure bytecode)
print("Test 3: Array Operations");

let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let arr_sum = 0;
let j = 0;

# 1M array operations
while j < 1000000:
    let k = 0;
    while k < 10:
        arr_sum = arr_sum + arr[k];
        k = k + 1;
    end
    j = j + 1;
end

print("Array operations completed: " + arr_sum.toString());
print("");

# Test 4: Object Operations (Pure bytecode)
print("Test 4: Object Operations");

class PerformanceTest:
    let value = 0;
    let multiplier = 1;
    
    func add(self, n: Int):
        self.value = self.value + n * self.multiplier;
    end
    
    func get_value(self) -> Int:
        return self.value;
    end
end

let obj = PerformanceTest();
let m = 0;

# 100K object operations
while m < 100000:
    obj.add(m);
    m = m + 1;
end

print("Object operations completed: " + obj.get_value().toString());
print("");

# Test 5: String Operations (Pure bytecode)
print("Test 5: String Operations");

let str = "Hello, World! ";
let str_result = "";
let n = 0;

# 10K string concatenations
while n < 10000:
    str_result = str_result + str;
    n = n + 1;
end

print("String operations completed (length: " + str_result.length.toString() + ")");
print("");

# Test 6: Library Method Calls (Pure bytecode)
print("Test 6: Library Method Calls");

let map = maps.create();
let set = sets.create();
let tree = trees.create();

# 10K library operations
let p = 0;
while p < 10000:
    map.set("key" + p.toString(), p);
    set.add(p);
    tree.insert(p);
    p = p + 1;
end

print("Library operations completed");
print("Map size: " + map.size.toString());
print("Set size: " + set.size.toString());
print("Tree size: " + tree.size.toString());
print("");

print("=== Benchmark Complete ===");
